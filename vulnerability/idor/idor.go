package idor

import (
	"crypto/md5"
	"encoding/hex"
	"log"
	"net/http"
	"strconv"

	"github.com/julienschmidt/httprouter"

	"github.com/ShiftLeftSecurity/shiftleft-go-demo/user/session"
	"github.com/ShiftLeftSecurity/shiftleft-go-demo/util"
	// "github.com/ShiftLeftSecurity/shiftleft-go-demo/util/middleware"
)

type IDOR struct{}

func New() IDOR {
	return IDOR{}
}

func (self IDOR) SetRouter(r *httprouter.Router) {
	// mw := middleware.New()
	// r.GET("/idor1", mw.LoggingMiddleware(mw.CapturePanic(mw.AuthCheck(idor1Handler))))
	// r.POST("/idor1action", mw.LoggingMiddleware(mw.CapturePanic(mw.AuthCheck(idor1ActionHandler))))
	// r.GET("/idor2", mw.LoggingMiddleware(mw.CapturePanic(mw.AuthCheck(idor2Handler))))
	// r.POST("/idor2action", mw.LoggingMiddleware(mw.CapturePanic(mw.AuthCheck(idor2ActionHandler))))
	r.GET("/idor1", idor1Handler)
	r.POST("/idor1action", idor1ActionHandler)
	r.GET("/idor2", idor2Handler)
	r.POST("/idor2action", idor2ActionHandler)
}

type DataResponse struct {
	Status  string `json:"status"`
	Message string `json:"message"`
}

func idor1Handler(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {
	session := session.New()
	sid := session.GetSession(r, "id")
	p := NewProfile()
	p.GetData(sid)

	data := make(map[string]interface{})

	data["title"] = "Insecure Direct Object References"
	data["uid"] = strconv.Itoa(p.Uid)
	data["name"] = p.Name
	data["city"] = p.City
	data["number"] = p.PhoneNumber

	util.SafeRender(w, r, "template.idor1", data)
}

func idor2Handler(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {
	session := session.New()
	sid := session.GetSession(r, "id")
	p := NewProfile()
	p.GetData(sid)

	data := make(map[string]interface{})
	signature := Md5Sum(sid)

	data["signature"] = signature
	data["title"] = "Insecure Direct Object References"
	data["uid"] = strconv.Itoa(p.Uid)
	data["name"] = p.Name
	data["city"] = p.City
	data["number"] = p.PhoneNumber

	util.SafeRender(w, r, "template.idor2", data)
}

func idor1ActionHandler(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {
	session := session.New()
	sid := session.GetSession(r, "id")
	p := NewProfile()
	p.GetData(sid)

	/* handle request response with json */
	if r.Method == "POST" {
		cid := util.GetCookie(r, "Uid")
		uid := HTMLEscapeString(r.FormValue("uid"))
		name := HTMLEscapeString(r.FormValue("name"))
		city := HTMLEscapeString(r.FormValue("city"))
		number := HTMLEscapeString(r.FormValue("number"))

		res := &DataResponse{}
		if uid != cid || uid == "" || cid == "" {
			res.Status = "0"
			res.Message = "Missing User Id"
			log.Println("Update Error")
		} else {
			if util.CheckLevel(r) { // level == high
				uid = sid // set uid that fetch from session this use to prevent unauthorize users force update other user profile
			}

			err = p.UpdateProfile(name, city, number, uid)
			if err != nil {
				log.Println(err.Error())
			}
			res.Status = "1"
			res.Message = "Update Success"
			log.Println("Update Success")
		}
		util.RenderAsJson(w, res)
	}
}

func idor2ActionHandler(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {
	log.Printf("got to handler")

	session := session.New()
	sid := session.GetSession(r, "id")
	p := NewProfile()
	p.GetData(sid)

	/* handle request response with json */
	if r.Method == "POST" {
		log.Printf("got into if")

		sign := HTMLEscapeString(r.FormValue("signature"))
		log.Printf("got sign")
		uid := HTMLEscapeString(r.FormValue("uid"))
		name := HTMLEscapeString(r.FormValue("name"))
		city := HTMLEscapeString(r.FormValue("city"))
		number := HTMLEscapeString(r.FormValue("number"))

		log.Printf("got all values")
		signature := Md5Sum(uid)
		log.Printf("got signature")

		res := &DataResponse{}
		log.Printf("before checking sign, signature")
		if sign != signature {
			log.Printf("%s != %s", sign, signature)

			res.Status = "0"
			res.Message = "Integrity Error"
			log.Println("Update Error")
		} else {
			log.Printf("signature == sign")

			if util.CheckLevel(r) { // level == high
				uid = sid // set uid that fetch from session this use to prevent unauthorize users force update other user profile
			}
			log.Printf("update now!")
			err = p.UpdateProfile(name, city, number, uid)
			if err != nil {
				log.Println(err.Error())
			}
			res.Status = "1"
			res.Message = "Update Success"
			log.Println("Update Success")
		}
		util.RenderAsJson(w, res)
	}
}

// HashingConfig allows adjusting security parameters based on evolving security standards
type HashingConfig struct {
    BcryptCost     int
    Argon2Time     uint32
    Argon2Memory   uint32
    Argon2Threads  uint8
    Argon2KeyLen   uint32
}

// DefaultHashingConfig provides recommended security parameters
func DefaultHashingConfig() HashingConfig {
    return HashingConfig{
        BcryptCost:     12,
        Argon2Time:     1,
        Argon2Memory:   64 * 1024,
        Argon2Threads:  4,
        Argon2KeyLen:   32,
    }
}

// SecureHash replaces Md5Sum with SHA-256 for general purpose hashing
// SHA-256 is cryptographically stronger than MD5
func SecureHash(text string) string {
    hasher := sha256.New()
    hasher.Write([]byte(text))
    return hex.EncodeToString(hasher.Sum(nil))
}

// SecurePasswordHash provides specialized password hashing using bcrypt
// with salting and configurable cost factor
func SecurePasswordHash(password string, config HashingConfig) (string, error) {
    // Using configurable cost factor instead of hardcoded value
    hashedBytes, err := bcrypt.GenerateFromPassword([]byte(password), config.BcryptCost)
    if err != nil {
        return "", err
    }
    return string(hashedBytes), nil
}

// VerifyBcryptPassword verifies a password against a bcrypt hash using constant-time comparison
func VerifyBcryptPassword(hashedPassword string, plainPassword string) bool {
    err := bcrypt.CompareHashAndPassword([]byte(hashedPassword), []byte(plainPassword))
    return err == nil
}

// SecurePasswordHashWithPepper adds server-side secret (pepper) for additional protection
func SecurePasswordHashWithPepper(password string, pepper []byte, config HashingConfig) (string, error) {
    // Combine password with pepper before hashing for additional security
    combined := append([]byte(password), pepper...)
    hashedBytes, err := bcrypt.GenerateFromPassword(combined, config.BcryptCost)
    if err != nil {
        return "", err
    }
    return string(hashedBytes), nil
}

// VerifyBcryptPasswordWithPepper verifies a peppered password
func VerifyBcryptPasswordWithPepper(hashedPassword string, plainPassword string, pepper []byte) bool {
    combined := append([]byte(plainPassword), pepper...)
    err := bcrypt.CompareHashAndPassword([]byte(hashedPassword), combined)
    return err == nil
}

// Argon2IdHash provides password hashing using Argon2id for critical systems
// Argon2id is resistant to both GPU and ASIC attacks
func Argon2IdHash(password string, config HashingConfig) (string, error) {
    // Generate a random salt
    salt := make([]byte, 16)
    if _, err := rand.Read(salt); err != nil {
        return "", err
    }
    
    // Hash the password with configurable parameters
    hash := argon2.IDKey(
        []byte(password), 
        salt, 
        config.Argon2Time, 
        config.Argon2Memory, 
        config.Argon2Threads, 
        config.Argon2KeyLen,
    )
    
    // Encode as base64
    b64Salt := base64.RawStdEncoding.EncodeToString(salt)
    b64Hash := base64.RawStdEncoding.EncodeToString(hash)
    
    // Format with parameters for storage
    encodedHash := fmt.Sprintf("$argon2id$v=%d$m=%d,t=%d,p=%d$%s$%s",
        argon2.Version, config.Argon2Memory, config.Argon2Time, 
        config.Argon2Threads, b64Salt, b64Hash)
    
    return encodedHash, nil
}

// VerifyArgon2idPassword verifies a password against an Argon2id hash using constant-time comparison
func VerifyArgon2idPassword(encodedHash string, plainPassword string) (bool, error) {
    // Extract the parameters, salt and key from the encoded hash
    vals := strings.Split(encodedHash, "$")
    if len(vals) != 6 {
        return false, errors.New("invalid hash format")
    }
    
    var version int
    var memory, time uint32
    var threads uint8
    
    _, err := fmt.Sscanf(vals[2], "v=%d", &version)
    if err != nil {
        return false, err
    }
    
    _, err = fmt.Sscanf(vals[3], "m=%d,t=%d,p=%d", &memory, &time, &threads)
    if err != nil {
        return false, err
    }
    
    salt, err := base64.RawStdEncoding.DecodeString(vals[4])
    if err != nil {
        return false, err
    }
    
    decodedHash, err := base64.RawStdEncoding.DecodeString(vals[5])
    if err != nil {
        return false, err
    }
    
    // Compute the hash of the provided password with the same parameters
    keyLen := uint32(len(decodedHash))
    comparisonHash := argon2.IDKey([]byte(plainPassword), salt, time, memory, threads, keyLen)
    
    // Constant-time comparison to prevent timing attacks
    return subtle.ConstantTimeCompare(decodedHash, comparisonHash) == 1, nil
}

// UpdateHashIfNeeded checks if the stored hash uses a deprecated algorithm and upgrades it
func UpdateHashIfNeeded(storedHash string, password string) (string, bool, error) {
    needsUpdate := false
    var newHash string
    var err error
    
    // Check if it's a bcrypt hash (starts with $2a$, $2b$ or $2y$)
    if strings.HasPrefix(storedHash, "$2") {
        // Verify the password is correct
        if !VerifyBcryptPassword(storedHash, password) {
            return "", false, errors.New("password verification failed")
        }
        
        // Check if the cost factor is less than the recommended value
        currentCost, err := bcrypt.Cost([]byte(storedHash))
        if err != nil {
            return "", false, err
        }
        
        config := DefaultHashingConfig()
        if currentCost < config.BcryptCost {
            // Upgrade to higher cost bcrypt
            newHash, err = SecurePasswordHash(password, config)
            needsUpdate = true
        }
    } else if strings.HasPrefix(storedHash, "$argon2id$") {
        // For Argon2id, we might want to update parameters based on the encoded values
        // Verify first
        valid, err := VerifyArgon2idPassword(storedHash, password)
        if err != nil || !valid {
            return "", false, errors.New("password verification failed")
        }
        
        // Parse the hash to check parameters
        vals := strings.Split(storedHash, "$")
        if len(vals) != 6 {
            return "", false, errors.New("invalid hash format")
        }
        
        var version int
        var memory, time uint32
        var threads uint8
        
        _, err = fmt.Sscanf(vals[2], "v=%d", &version)
        if err != nil {
            return "", false, err
        }
        
        _, err = fmt.Sscanf(vals[3], "m=%d,t=%d,p=%d", &memory, &time, &threads)
        if err != nil {
            return "", false, err
        }
        
        config := DefaultHashingConfig()
        // Check if parameters need upgrading
        if memory < config.Argon2Memory || time < config.Argon2Time {
            newHash, err = Argon2IdHash(password, config)
            needsUpdate = true
        }
    } else {
        // Any other hash format is considered outdated (including SHA-256)
        // Upgrade to Argon2id
        newHash, err = Argon2IdHash(password, DefaultHashingConfig())
        needsUpdate = true
    }
    
    if err != nil {
        return "", false, err
    }
    
    return newHash, needsUpdate, nil
}

// Original MD5 function retained but marked as deprecated
// Use SecureHash, SecurePasswordHash, or Argon2IdHash instead
func Md5Sum(text string) string {
    // Deprecated: MD5 is cryptographically weak and vulnerable to collision attacks
    // This function is retained for backward compatibility only
    // Use SecureHash instead for general purpose hashing
    return SecureHash(text)
}

