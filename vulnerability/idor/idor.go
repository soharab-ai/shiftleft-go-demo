package idor

import (
	"crypto/md5"
	"encoding/hex"
	"log"
	"net/http"
	"strconv"

	"github.com/julienschmidt/httprouter"

	"github.com/ShiftLeftSecurity/shiftleft-go-demo/user/session"
	"github.com/ShiftLeftSecurity/shiftleft-go-demo/util"
	// "github.com/ShiftLeftSecurity/shiftleft-go-demo/util/middleware"
)

type IDOR struct{}

func New() IDOR {
	return IDOR{}
}

func (self IDOR) SetRouter(r *httprouter.Router) {
	// mw := middleware.New()
	// r.GET("/idor1", mw.LoggingMiddleware(mw.CapturePanic(mw.AuthCheck(idor1Handler))))
	// r.POST("/idor1action", mw.LoggingMiddleware(mw.CapturePanic(mw.AuthCheck(idor1ActionHandler))))
	// r.GET("/idor2", mw.LoggingMiddleware(mw.CapturePanic(mw.AuthCheck(idor2Handler))))
	// r.POST("/idor2action", mw.LoggingMiddleware(mw.CapturePanic(mw.AuthCheck(idor2ActionHandler))))
	r.GET("/idor1", idor1Handler)
	r.POST("/idor1action", idor1ActionHandler)
	r.GET("/idor2", idor2Handler)
	r.POST("/idor2action", idor2ActionHandler)
}

type DataResponse struct {
	Status  string `json:"status"`
	Message string `json:"message"`
}

func idor1Handler(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {
	session := session.New()
	sid := session.GetSession(r, "id")
	p := NewProfile()
	p.GetData(sid)

	data := make(map[string]interface{})

	data["title"] = "Insecure Direct Object References"
	data["uid"] = strconv.Itoa(p.Uid)
	data["name"] = p.Name
	data["city"] = p.City
	data["number"] = p.PhoneNumber

	util.SafeRender(w, r, "template.idor1", data)
}

func idor2Handler(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {
	session := session.New()
	sid := session.GetSession(r, "id")
	p := NewProfile()
	p.GetData(sid)

	data := make(map[string]interface{})
	signature := Md5Sum(sid)

	data["signature"] = signature
	data["title"] = "Insecure Direct Object References"
	data["uid"] = strconv.Itoa(p.Uid)
	data["name"] = p.Name
	data["city"] = p.City
	data["number"] = p.PhoneNumber

	util.SafeRender(w, r, "template.idor2", data)
}

func idor1ActionHandler(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {
	session := session.New()
	sid := session.GetSession(r, "id")
	p := NewProfile()
	p.GetData(sid)

	/* handle request response with json */
	if r.Method == "POST" {
		cid := util.GetCookie(r, "Uid")
		uid := HTMLEscapeString(r.FormValue("uid"))
		name := HTMLEscapeString(r.FormValue("name"))
		city := HTMLEscapeString(r.FormValue("city"))
		number := HTMLEscapeString(r.FormValue("number"))

		res := &DataResponse{}
		if uid != cid || uid == "" || cid == "" {
			res.Status = "0"
			res.Message = "Missing User Id"
			log.Println("Update Error")
		} else {
			if util.CheckLevel(r) { // level == high
				uid = sid // set uid that fetch from session this use to prevent unauthorize users force update other user profile
			}

			err = p.UpdateProfile(name, city, number, uid)
			if err != nil {
				log.Println(err.Error())
			}
			res.Status = "1"
			res.Message = "Update Success"
			log.Println("Update Success")
		}
		util.RenderAsJson(w, res)
	}
}

func idor2ActionHandler(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {
	log.Printf("got to handler")

	session := session.New()
	sid := session.GetSession(r, "id")
	p := NewProfile()
	p.GetData(sid)

	/* handle request response with json */
	if r.Method == "POST" {
		log.Printf("got into if")

		sign := HTMLEscapeString(r.FormValue("signature"))
		log.Printf("got sign")
		uid := HTMLEscapeString(r.FormValue("uid"))
		name := HTMLEscapeString(r.FormValue("name"))
		city := HTMLEscapeString(r.FormValue("city"))
		number := HTMLEscapeString(r.FormValue("number"))

		log.Printf("got all values")
		signature := Md5Sum(uid)
		log.Printf("got signature")

		res := &DataResponse{}
		log.Printf("before checking sign, signature")
		if sign != signature {
			log.Printf("%s != %s", sign, signature)

			res.Status = "0"
			res.Message = "Integrity Error"
			log.Println("Update Error")
		} else {
			log.Printf("signature == sign")

			if util.CheckLevel(r) { // level == high
				uid = sid // set uid that fetch from session this use to prevent unauthorize users force update other user profile
			}
			log.Printf("update now!")
			err = p.UpdateProfile(name, city, number, uid)
			if err != nil {
				log.Println(err.Error())
			}
			res.Status = "1"
			res.Message = "Update Success"
			log.Println("Update Success")
		}
		util.RenderAsJson(w, res)
	}
}

func Md5Sum(text string) string {
// HashingAlgorithm represents supported hashing algorithms
type HashingAlgorithm string

const (
	SHA256    HashingAlgorithm = "SHA256"
	SHA512    HashingAlgorithm = "SHA512"
	SHA3_256  HashingAlgorithm = "SHA3_256"
	BLAKE2b   HashingAlgorithm = "BLAKE2b"
)

// DefaultHashAlgorithm defines the default hashing algorithm to use
const DefaultHashAlgorithm = SHA3_256

// DefaultBcryptCost defines the default cost parameter for bcrypt
const DefaultBcryptCost = 12

// SecureHash replaces the original Md5Sum function with a more secure implementation
// Renamed from Md5Sum to SecureHash to accurately reflect its purpose
func SecureHash(text string) (string, error) {
	// Default to SHA3-256 as recommended in mitigation notes
	return GenerateHash(text, DefaultHashAlgorithm)
}

// GenerateHash provides a flexible approach for hashing with multiple algorithm options
// Implements suggestion #2 from mitigation notes
func GenerateHash(text string, algorithm HashingAlgorithm) (string, error) {
	var hashBytes []byte
	var err error

	switch algorithm {
	case SHA256:
		hasher := sha256.New()
		_, err = hasher.Write([]byte(text))
		if err != nil {
			return "", err
		}
		hashBytes = hasher.Sum(nil)
	case SHA512:
		hasher := sha512.New()
		_, err = hasher.Write([]byte(text))
		if err != nil {
			return "", err
		}
		hashBytes = hasher.Sum(nil)
	case SHA3_256:
		hasher := sha3.New256()
		_, err = hasher.Write([]byte(text))
		if err != nil {
			return "", err
		}
		hashBytes = hasher.Sum(nil)
	case BLAKE2b:
		hasher, err := blake2b.New256(nil)
		if err != nil {
			return "", err
		}
		_, err = hasher.Write([]byte(text))
		if err != nil {
			return "", err
		}
		hashBytes = hasher.Sum(nil)
	default:
		return "", errors.New("unsupported hash algorithm")
	}

	// Zero out the input data from memory for security
	// Implementing suggestion #7 from mitigation notes
	defer func() {
		// Clear the text from memory when no longer needed
		textBytes := []byte(text)
		for i := range textBytes {
			textBytes[i] = 0
		}
	}()

	return hex.EncodeToString(hashBytes), nil
}

// HashPassword provides specialized password hashing using bcrypt with configurable cost
// Implements suggestion #3 from mitigation notes
func HashPassword(password string, cost int) (string, error) {
	// Validate and adjust cost if necessary
	if cost < bcrypt.MinCost || cost > bcrypt.MaxCost {
		cost = DefaultBcryptCost
	}
	
	// Generate password hash with specified cost
	bytes, err := bcrypt.GenerateFromPassword([]byte(password), cost)
	
	// Zero out the password from memory for security
	// Implementing suggestion #7 from mitigation notes
	defer func() {
		passwordBytes := []byte(password)
		for i := range passwordBytes {
			passwordBytes[i] = 0
		}
	}()
	
	return string(bytes), err
}

// HashPasswordWithDefaultCost provides a simplified interface for password hashing
func HashPasswordWithDefaultCost(password string) (string, error) {
	return HashPassword(password, DefaultBcryptCost)
}

// CheckPasswordHash verifies a password against a bcrypt hash
func CheckPasswordHash(password, hash string) bool {
	err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
	
	// Zero out the password from memory for security
	defer func() {
		passwordBytes := []byte(password)
		for i := range passwordBytes {
			passwordBytes[i] = 0
		}
	}()
	
	return err == nil
}

// SecureCompare performs a constant-time comparison of two strings
// Helps prevent timing attacks when comparing sensitive values
func SecureCompare(a, b string) bool {
	return subtle.ConstantTimeCompare([]byte(a), []byte(b)) == 1
}

// For backward compatibility - deprecated
// This function is maintained only for backward compatibility
func Md5Sum(text string) string {
	hash, err := SecureHash(text)
	if err != nil {
		// In case of error, return empty string
		// This maintains the original function signature but is not ideal
		// Calling code should be updated to use SecureHash instead
		return ""
	}
	return hash
}
