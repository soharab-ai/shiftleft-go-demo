package idor

import (
	"crypto/md5"
	"encoding/hex"
	"log"
	"net/http"
	"strconv"

	"github.com/julienschmidt/httprouter"

	"github.com/ShiftLeftSecurity/shiftleft-go-demo/user/session"
	"github.com/ShiftLeftSecurity/shiftleft-go-demo/util"
	// "github.com/ShiftLeftSecurity/shiftleft-go-demo/util/middleware"
)

type IDOR struct{}

func New() IDOR {
	return IDOR{}
}

func (self IDOR) SetRouter(r *httprouter.Router) {
	// mw := middleware.New()
	// r.GET("/idor1", mw.LoggingMiddleware(mw.CapturePanic(mw.AuthCheck(idor1Handler))))
	// r.POST("/idor1action", mw.LoggingMiddleware(mw.CapturePanic(mw.AuthCheck(idor1ActionHandler))))
	// r.GET("/idor2", mw.LoggingMiddleware(mw.CapturePanic(mw.AuthCheck(idor2Handler))))
	// r.POST("/idor2action", mw.LoggingMiddleware(mw.CapturePanic(mw.AuthCheck(idor2ActionHandler))))
	r.GET("/idor1", idor1Handler)
	r.POST("/idor1action", idor1ActionHandler)
	r.GET("/idor2", idor2Handler)
	r.POST("/idor2action", idor2ActionHandler)
}

type DataResponse struct {
	Status  string `json:"status"`
	Message string `json:"message"`
}

func idor1Handler(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {
	session := session.New()
	sid := session.GetSession(r, "id")
	p := NewProfile()
	p.GetData(sid)

	data := make(map[string]interface{})

	data["title"] = "Insecure Direct Object References"
	data["uid"] = strconv.Itoa(p.Uid)
	data["name"] = p.Name
	data["city"] = p.City
	data["number"] = p.PhoneNumber

	util.SafeRender(w, r, "template.idor1", data)
}

func idor2Handler(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {
	session := session.New()
	sid := session.GetSession(r, "id")
	p := NewProfile()
	p.GetData(sid)

	data := make(map[string]interface{})
	signature := Md5Sum(sid)

	data["signature"] = signature
	data["title"] = "Insecure Direct Object References"
	data["uid"] = strconv.Itoa(p.Uid)
	data["name"] = p.Name
	data["city"] = p.City
	data["number"] = p.PhoneNumber

	util.SafeRender(w, r, "template.idor2", data)
}

func idor1ActionHandler(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {
	session := session.New()
	sid := session.GetSession(r, "id")
	p := NewProfile()
	p.GetData(sid)

	/* handle request response with json */
	if r.Method == "POST" {
		cid := util.GetCookie(r, "Uid")
		uid := HTMLEscapeString(r.FormValue("uid"))
		name := HTMLEscapeString(r.FormValue("name"))
		city := HTMLEscapeString(r.FormValue("city"))
		number := HTMLEscapeString(r.FormValue("number"))

		res := &DataResponse{}
		if uid != cid || uid == "" || cid == "" {
			res.Status = "0"
			res.Message = "Missing User Id"
			log.Println("Update Error")
		} else {
			if util.CheckLevel(r) { // level == high
				uid = sid // set uid that fetch from session this use to prevent unauthorize users force update other user profile
			}

			err = p.UpdateProfile(name, city, number, uid)
			if err != nil {
				log.Println(err.Error())
			}
			res.Status = "1"
			res.Message = "Update Success"
			log.Println("Update Success")
		}
		util.RenderAsJson(w, res)
	}
}

func idor2ActionHandler(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {
	log.Printf("got to handler")

	session := session.New()
	sid := session.GetSession(r, "id")
	p := NewProfile()
	p.GetData(sid)

	/* handle request response with json */
	if r.Method == "POST" {
		log.Printf("got into if")

		sign := HTMLEscapeString(r.FormValue("signature"))
		log.Printf("got sign")
		uid := HTMLEscapeString(r.FormValue("uid"))
		name := HTMLEscapeString(r.FormValue("name"))
		city := HTMLEscapeString(r.FormValue("city"))
		number := HTMLEscapeString(r.FormValue("number"))

		log.Printf("got all values")
		signature := Md5Sum(uid)
		log.Printf("got signature")

		res := &DataResponse{}
		log.Printf("before checking sign, signature")
		if sign != signature {
			log.Printf("%s != %s", sign, signature)

			res.Status = "0"
			res.Message = "Integrity Error"
			log.Println("Update Error")
		} else {
			log.Printf("signature == sign")

			if util.CheckLevel(r) { // level == high
				uid = sid // set uid that fetch from session this use to prevent unauthorize users force update other user profile
			}
			log.Printf("update now!")
			err = p.UpdateProfile(name, city, number, uid)
			if err != nil {
				log.Println(err.Error())
			}
			res.Status = "1"
			res.Message = "Update Success"
			log.Println("Update Success")
		}
		util.RenderAsJson(w, res)
	}
}

func Md5Sum(text string) string {
// Algorithm versions for hash identification
const (
	ALG_SHA3_256 = "SHA3-256"
	ALG_BCRYPT   = "BCRYPT"
)

// SecureDataHash replaces MD5Sum for general data integrity purposes
// using the more secure SHA-3 algorithm instead of weak MD5
// Implemented with salt to prevent rainbow table attacks
func SecureDataHash(text string, salt []byte) string {
	// Using SHA-3 as recommended in mitigation notes
	hasher := sha3.New256()
	hasher.Write(salt)
	hasher.Write([]byte(text))
	hash := hasher.Sum(nil)
	// Add algorithm version for future compatibility
	return fmt.Sprintf("%s:%s:%s", ALG_SHA3_256, hex.EncodeToString(salt), hex.EncodeToString(hash))
}

// GenerateRandomSalt creates a cryptographically secure random salt
func GenerateRandomSalt(length int) ([]byte, error) {
	salt := make([]byte, length)
	_, err := rand.Read(salt)
	if err != nil {
		return nil, err
	}
	return salt, nil
}

// SecureHashPassword should be used specifically for password hashing
// using bcrypt with configurable cost factor for security and future-proofing
func SecureHashPassword(password string, costFactor int) (string, error) {
	// Implement configurable cost factor as suggested in mitigation notes
	if costFactor < bcrypt.MinCost {
		costFactor = 12 // Default if not properly specified
	}
	bytes, err := bcrypt.GenerateFromPassword([]byte(password), costFactor)
	if err != nil {
		return "", err
	}
	// Add algorithm version for future compatibility
	return fmt.Sprintf("%s:%s", ALG_BCRYPT, string(bytes)), nil
}

// Md5Sum is deprecated and should not be used as MD5 is cryptographically weak
// This is kept for backward compatibility but marked as deprecated
// Use SecureDataHash or SecureHashPassword instead
func Md5Sum(text string) string {
	// Generate a salt for the backward compatibility function
	salt, err := GenerateRandomSalt(16)
	if err != nil {
		// Fallback to a simple salt if random generation fails
		salt = []byte("default_salt_value")
	}
	// Redirecting to more secure implementation with salt
	return SecureDataHash(text, salt)
}
