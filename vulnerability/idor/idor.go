package idor

import (
	"crypto/md5"
	"encoding/hex"
	"log"
	"net/http"
	"strconv"

	"github.com/julienschmidt/httprouter"

	"github.com/ShiftLeftSecurity/shiftleft-go-demo/user/session"
	"github.com/ShiftLeftSecurity/shiftleft-go-demo/util"
	// "github.com/ShiftLeftSecurity/shiftleft-go-demo/util/middleware"
)

type IDOR struct{}

func New() IDOR {
	return IDOR{}
}

func (self IDOR) SetRouter(r *httprouter.Router) {
	// mw := middleware.New()
	// r.GET("/idor1", mw.LoggingMiddleware(mw.CapturePanic(mw.AuthCheck(idor1Handler))))
	// r.POST("/idor1action", mw.LoggingMiddleware(mw.CapturePanic(mw.AuthCheck(idor1ActionHandler))))
	// r.GET("/idor2", mw.LoggingMiddleware(mw.CapturePanic(mw.AuthCheck(idor2Handler))))
	// r.POST("/idor2action", mw.LoggingMiddleware(mw.CapturePanic(mw.AuthCheck(idor2ActionHandler))))
	r.GET("/idor1", idor1Handler)
	r.POST("/idor1action", idor1ActionHandler)
	r.GET("/idor2", idor2Handler)
	r.POST("/idor2action", idor2ActionHandler)
}

type DataResponse struct {
	Status  string `json:"status"`
	Message string `json:"message"`
}

func idor1Handler(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {
	session := session.New()
	sid := session.GetSession(r, "id")
	p := NewProfile()
	p.GetData(sid)

	data := make(map[string]interface{})

	data["title"] = "Insecure Direct Object References"
	data["uid"] = strconv.Itoa(p.Uid)
	data["name"] = p.Name
	data["city"] = p.City
	data["number"] = p.PhoneNumber

	util.SafeRender(w, r, "template.idor1", data)
}

func idor2Handler(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {
	session := session.New()
	sid := session.GetSession(r, "id")
	p := NewProfile()
	p.GetData(sid)

	data := make(map[string]interface{})
	signature := Md5Sum(sid)

	data["signature"] = signature
	data["title"] = "Insecure Direct Object References"
	data["uid"] = strconv.Itoa(p.Uid)
	data["name"] = p.Name
	data["city"] = p.City
	data["number"] = p.PhoneNumber

	util.SafeRender(w, r, "template.idor2", data)
}

func idor1ActionHandler(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {
	session := session.New()
	sid := session.GetSession(r, "id")
	p := NewProfile()
	p.GetData(sid)

	/* handle request response with json */
	if r.Method == "POST" {
		cid := util.GetCookie(r, "Uid")
		uid := HTMLEscapeString(r.FormValue("uid"))
		name := HTMLEscapeString(r.FormValue("name"))
		city := HTMLEscapeString(r.FormValue("city"))
		number := HTMLEscapeString(r.FormValue("number"))

		res := &DataResponse{}
		if uid != cid || uid == "" || cid == "" {
			res.Status = "0"
			res.Message = "Missing User Id"
			log.Println("Update Error")
		} else {
			if util.CheckLevel(r) { // level == high
				uid = sid // set uid that fetch from session this use to prevent unauthorize users force update other user profile
			}

			err = p.UpdateProfile(name, city, number, uid)
			if err != nil {
				log.Println(err.Error())
			}
			res.Status = "1"
			res.Message = "Update Success"
			log.Println("Update Success")
		}
		util.RenderAsJson(w, res)
	}
}

func idor2ActionHandler(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {
	log.Printf("got to handler")

	session := session.New()
	sid := session.GetSession(r, "id")
	p := NewProfile()
	p.GetData(sid)

	/* handle request response with json */
	if r.Method == "POST" {
		log.Printf("got into if")

		sign := HTMLEscapeString(r.FormValue("signature"))
		log.Printf("got sign")
		uid := HTMLEscapeString(r.FormValue("uid"))
		name := HTMLEscapeString(r.FormValue("name"))
		city := HTMLEscapeString(r.FormValue("city"))
		number := HTMLEscapeString(r.FormValue("number"))

		log.Printf("got all values")
		signature := Md5Sum(uid)
		log.Printf("got signature")

		res := &DataResponse{}
		log.Printf("before checking sign, signature")
		if sign != signature {
			log.Printf("%s != %s", sign, signature)

			res.Status = "0"
			res.Message = "Integrity Error"
			log.Println("Update Error")
		} else {
			log.Printf("signature == sign")

			if util.CheckLevel(r) { // level == high
				uid = sid // set uid that fetch from session this use to prevent unauthorize users force update other user profile
			}
			log.Printf("update now!")
			err = p.UpdateProfile(name, city, number, uid)
			if err != nil {
				log.Println(err.Error())
			}
			res.Status = "1"
			res.Message = "Update Success"
			log.Println("Update Success")
		}
		util.RenderAsJson(w, res)
	}
}

func Md5Sum(text string) string {
// StrongHash replaces the weak MD5 function with HMAC-SHA256 to prevent length extension attacks
func StrongHash(text string) string {
    // Using HMAC-SHA256 instead of simple SHA-256 for protection against length extension attacks
    secretKey := getApplicationSecret() // This should retrieve a secret key from secure storage
    h := hmac.New(sha256.New, []byte(secretKey))
    h.Write([]byte(text))
    return hex.EncodeToString(h.Sum(nil))
}

// getApplicationSecret retrieves the application secret from secure storage
// In a real application, this should come from environment variables, a secure vault, etc.
func getApplicationSecret() string {
    // This is a placeholder - in production, retrieve from secure configuration
    // Do not hardcode secrets in source code
    return "APPLICATION_SECRET_SHOULD_BE_STORED_SECURELY"
}

// SecurePasswordHash provides specialized password hashing with Argon2id
// which is more resistant to GPU and ASIC attacks than bcrypt
func SecurePasswordHash(password string) (string, error) {
    // Generate a random salt
    salt := make([]byte, 16)
    if _, err := rand.Read(salt); err != nil {
        return "", err
    }
    
    // Argon2id parameters
    time := uint32(1)        // Number of iterations
    memory := uint32(64*1024) // 64MB of memory
    threads := uint8(4)      // 4 threads of parallelism
    keyLen := uint32(32)     // 32-byte output key
    
    // Hash the password using Argon2id
    hash := argon2.IDKey([]byte(password), salt, time, memory, threads, keyLen)
    
    // Create versioned format: v1$argon2id$m=65536,t=1,p=4$[salt]$[hash]
    saltBase64 := base64.RawStdEncoding.EncodeToString(salt)
    hashBase64 := base64.RawStdEncoding.EncodeToString(hash)
    
    encodedHash := fmt.Sprintf("v1$argon2id$m=%d,t=%d,p=%d$%s$%s",
        memory, time, threads, saltBase64, hashBase64)
    
    return encodedHash, nil
}

// VerifyPassword compares a password against an Argon2id hash using constant time comparison
func VerifyPassword(encodedHash, password string) (bool, error) {
    // Split the encoded hash into parts: version, algorithm, parameters, salt, hash
    parts := strings.Split(encodedHash, "$")
    if len(parts) != 5 {
        return false, fmt.Errorf("invalid hash format")
    }
    
    // Check version and algorithm
    if parts[0] != "v1" || parts[1] != "argon2id" {
        return false, fmt.Errorf("unsupported hash version or algorithm")
    }
    
    // Parse parameters
    var memory, time uint32
    var threads uint8
    
    _, err := fmt.Sscanf(parts[2], "m=%d,t=%d,p=%d", &memory, &time, &threads)
    if err != nil {
        return false, fmt.Errorf("invalid hash parameters: %v", err)
    }
    
    // Decode salt and hash
    salt, err := base64.RawStdEncoding.DecodeString(parts[3])
    if err != nil {
        return false, fmt.Errorf("invalid salt encoding: %v", err)
    }
    
    decodedHash, err := base64.RawStdEncoding.DecodeString(parts[4])
    if err != nil {
        return false, fmt.Errorf("invalid hash encoding: %v", err)
    }
    
    // Compute hash for provided password with same parameters
    keyLen := uint32(len(decodedHash))
    computedHash := argon2.IDKey([]byte(password), salt, time, memory, threads, keyLen)
    
    // Constant-time comparison to prevent timing attacks
    match := true
    for i := range decodedHash {
        if i >= len(computedHash) || decodedHash[i] != computedHash[i] {
            match = false
        }
    }
    
    return match, nil
}

// BCryptSecurePasswordHash provides an alternative password hashing with bcrypt
// with a higher cost factor than default (12 instead of the default 10)
func BCryptSecurePasswordHash(password string) (string, error) {
    // Import needed for this function:
    // "golang.org/x/crypto/bcrypt"
    
    // Using bcrypt with increased cost factor (12 instead of default 10)
    // This would be used if your system can't use Argon2id for some reason
    //hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), 12)
    //if err != nil {
    //    return "", err
    //}
    //return string(hashedPassword), nil
    
    // This function is provided as a reference but disabled since Argon2id is preferred
    return "", fmt.Errorf("bcrypt implementation disabled in favor of Argon2id")
}
