package xss

import (
	"fmt"
	"html"
	"html/template"
	"log"
	"net/http"
	"regexp"

	"github.com/julienschmidt/httprouter"

	"github.com/ShiftLeftSecurity/shiftleft-go-demo/util"
	// "github.com/ShiftLeftSecurity/shiftleft-go-demo/util/middleware"
	"github.com/ShiftLeftSecurity/shiftleft-go-demo/vulnerability/sqli"
)

type XSS struct {
	Name string
}

func New() XSS {
	return XSS{}
}
func (XSS) SetRouter(r *httprouter.Router) {
	// mw := middleware.New()
	// r.GET("/xss1", mw.LoggingMiddleware(mw.CapturePanic(mw.AuthCheck(xss1Handler))))
	// r.POST("/xss1", mw.LoggingMiddleware(mw.CapturePanic(mw.AuthCheck(xss1Handler))))
	// r.GET("/xss2", mw.LoggingMiddleware(mw.CapturePanic(mw.AuthCheck(xss2Handler))))
	r.GET("/xss1", xss1Handler)
	r.POST("/xss1", xss1Handler)
	r.GET("/xss2", xss2Handler)
}

func xss1Handler(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {
// Create static policy objects once at initialization time for better performance
var (
	// HTML policy for user-generated content
	htmlPolicy = bluemonday.UGCPolicy()
	// More strict policy for search terms and other inputs
	strictPolicy = bluemonday.StrictPolicy()
	// Input validation pattern - only alphanumeric chars, spaces and limited punctuation
	validInputPattern = regexp.MustCompile(`^[a-zA-Z0-9\s\.\,\-\_\?\!]+$`)
)

func xss1Handler(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {
	// Enhanced CSP with additional directives
	w.Header().Set("Content-Security-Policy", "default-src 'self'; script-src 'self'; style-src 'self'; img-src 'self'; connect-src 'self'; font-src 'self'; object-src 'none'; media-src 'self'; frame-src 'none'")

	data := make(map[string]interfacenull)

	if r.Method == "GET" {
		term := r.FormValue("term")

		// First validate input before sanitization
		if term != "" && !validInputPattern.MatchString(term) {
			log.Printf("Potentially malicious input rejected: %s", strictPolicy.Sanitize(term))
			data["error"] = "Invalid input characters detected"
			util.SafeRender(w, r, "template.xss1", data)
			return
		}
		
		// Sanitize input - now separated from validation
		sanitizedTerm := htmlPolicy.Sanitize(term)
		
		if sanitizedTerm == "sql injection" {
			sanitizedTerm = "sqli"
		}

		// Get vulnerability details - ensure this is also sanitized
		vulnDetails := GetExp(sanitizedTerm)
		if vulnDetails != "" {
			// Sanitize vulnerability details too for consistency
			vulnDetails = htmlPolicy.Sanitize(vulnDetails)
		}

		// Pass raw data to template without HTML construction in code
		if term == "" {
			data["term"] = ""
		} else if vulnDetails == "" {
			data["value"] = sanitizedTerm
			data["notFound"] = true  // Template will format this appropriately
			data["searchTerm"] = sanitizedTerm
		} else {
			data["value"] = sanitizedTerm
			data["searchTerm"] = sanitizedTerm
			data["details"] = vulnDetails
		}
	}
	
	data["title"] = "Cross Site Scripting"
	
	// Error handling for template rendering
	err := util.SafeRender(w, r, "template.xss1", data)
	if err != nil {
		log.Printf("Template rendering error: %v", err)
		http.Error(w, "Internal server error", http.StatusInternalServerError)
	}
}

func xss2Handler(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {
	uid := r.FormValue("uid")

	if util.CheckLevel(r) { // level = high
		uid = HTMLEscapeString(uid)
	}

	p := sqli.NewProfile() // using sqli get profile module instead of create new function
	err := p.SafeQueryGetData(uid)

	if err != nil {
		log.Println(err.Error())
	}

	data := make(map[string]interface{})

	js := ` <script>
			var id = %s
			var name = "%s"
			var city = "%s"
			var number = "%s"
			</script>` // here is the mistake, render value to a javascript that came from client request

	inlineJS := fmt.Sprintf(js, uid, p.Name, p.City, p.PhoneNumber)

	data["title"] = "Cross Site Scripting"

	data["inlineJS"] = template.HTML(inlineJS) // this will render the javascript on client browser

	util.SafeRender(w, r, "template.xss2", data)
}

func HTMLEscapeString(text string) string {
	filter := regexp.MustCompile("<[^>]*>")
	output := filter.ReplaceAllString(text, "")
	return html.EscapeString(output)
}

func removeScriptTag(text string) string {
	// Using context-specific sanitization based on how this data will be used
	if text == "" {
		return ""
	}
	
	// Apply sanitization with error handling
	sanitized := htmlPolicy.Sanitize(text)
	
	// Additional validation for script-like content that might bypass sanitization
	if strings.Contains(strings.ToLower(sanitized), "script") || 
	   strings.Contains(strings.ToLower(sanitized), "onerror") ||
	   strings.Contains(strings.ToLower(sanitized), "javascript:") {
		log.Printf("Potentially dangerous content detected after sanitization: %s", strictPolicy.Sanitize(text))
		return "[Content removed for security]"
	}
	
	return sanitized
}

