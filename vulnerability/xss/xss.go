package xss

import (
	"fmt"
	"html"
	"html/template"
	"log"
	"net/http"
	"regexp"

	"github.com/julienschmidt/httprouter"

	"github.com/ShiftLeftSecurity/shiftleft-go-demo/util"
	// "github.com/ShiftLeftSecurity/shiftleft-go-demo/util/middleware"
	"github.com/ShiftLeftSecurity/shiftleft-go-demo/vulnerability/sqli"
)

type XSS struct {
	Name string
}

func New() XSS {
	return XSS{}
}
func (XSS) SetRouter(r *httprouter.Router) {
	// mw := middleware.New()
	// r.GET("/xss1", mw.LoggingMiddleware(mw.CapturePanic(mw.AuthCheck(xss1Handler))))
	// r.POST("/xss1", mw.LoggingMiddleware(mw.CapturePanic(mw.AuthCheck(xss1Handler))))
	// r.GET("/xss2", mw.LoggingMiddleware(mw.CapturePanic(mw.AuthCheck(xss2Handler))))
	r.GET("/xss1", xss1Handler)
	r.POST("/xss1", xss1Handler)
	r.GET("/xss2", xss2Handler)
}

func xss1Handler(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {
	/* template.HTML is a vulnerable function */

	data := make(map[string]interface{})

	if r.Method == "GET" {
		term := r.FormValue("term")

		if util.CheckLevel(r) { // level = high
			term = HTMLEscapeString(term)
		}

		if term == "sql injection" {
			term = "sqli"
		}

		term = removeScriptTag(term)
		vulnDetails := GetExp(term)

		notFound := fmt.Sprintf("<b><i>%s</i></b> not found", term)
		value := fmt.Sprintf("%s", term)

		if term == "" {
			data["term"] = ""
		} else if vulnDetails == "" {
			data["value"] = template.HTML(value)
			data["term"] = template.HTML(notFound) // vulnerable function
		} else {
			vuln := fmt.Sprintf("<b>%s</b>", term)
			data["value"] = template.HTML(value)
			data["term"] = template.HTML(vuln)
			data["details"] = vulnDetails
		}

	}
	data["title"] = "Cross Site Scripting"
	util.SafeRender(w, r, "template.xss1", data)
}

func xss2Handler(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {
	uid := r.FormValue("uid")

	// Validate uid as a numeric value if that's the expected input type
	if _, err := strconv.Atoi(uid); err != nil {
		http.Error(w, "Invalid input: UID must be numeric", http.StatusBadRequest)
		return
	}

	// Replace inactive sqli package with standard database functionality
	profile, err := getProfileData(uid)
	if err != nil {
		log.Println("Error querying profile: " + err.Error())
		http.Error(w, "Internal server error", http.StatusInternalServerError)
		return
	}

	// Use proper type for template data
	data := make(map[string]interfacenull)

	data["title"] = "Cross Site Scripting"
	data["userID"] = uid
	data["userName"] = profile.Name
	data["userCity"] = profile.City
	data["userPhone"] = profile.PhoneNumber

	// Add Content Security Policy header for additional XSS protection
	w.Header().Set("Content-Security-Policy", "default-src 'self'; script-src 'self'")

	// Create and execute template with proper HTML escaping
	tmpl, err := template.New("template.xss2").Delims("{{", "}}").Parse(`
		<!DOCTYPE html>
		<html>
		<head>
			<title>{{.title}}</title>
		</head>
		<body>
			<h1>User Profile</h1>
			<p>ID: {{.userID}}</p>
			<p>Name: {{.userName}}</p>
			<p>City: {{.userCity}}</p>
			<p>Phone: {{.userPhone}}</p>
		</body>
		</html>
	`)
	if err != nil {
		log.Println("Template error: " + err.Error())
		http.Error(w, "Internal server error", http.StatusInternalServerError)
		return
	}

	err = tmpl.Execute(w, data)
	if err != nil {
		log.Println("Template execution error: " + err.Error())
		http.Error(w, "Internal server error", http.StatusInternalServerError)
	}
}

// Profile represents user profile data
type Profile struct {
	Name        string
	City        string
	PhoneNumber string
}

// getProfileData retrieves user profile data safely
// This replaces functionality from the inactive shiftleft-go-demo/vulnerability/sqli package
func getProfileData(uid string) (Profile, error) {
	// In a real application, you would use a database connection from a connection pool
	// For demonstration purposes, we're returning mock data
	// db, err := sql.Open("your_database_driver", "connection_string")
	// if err != nil {
	//     return Profilenull, err
	// }
	// defer db.Close()
	
	// query := "SELECT name, city, phone FROM users WHERE id = ?"
	// row := db.QueryRow(query, uid)
	
	// var profile Profile
	// err = row.Scan(&profile.Name, &profile.City, &profile.PhoneNumber)
	// if err != nil {
	//     return Profilenull, err
	// }
	
	// Mock data for demonstration
	profile := Profile{
		Name:        "John Doe",
		City:        "New York",
		PhoneNumber: "555-1234",
	}
	
	return profile, nil
}


func HTMLEscapeString(text string) string {
	filter := regexp.MustCompile("<[^>]*>")
	output := filter.ReplaceAllString(text, "")
	return html.EscapeString(output)
}

func removeScriptTag(text string) string {
	filter := regexp.MustCompile("<script*>.*</script>")
	output := filter.ReplaceAllString(text, "")
	return output
}
