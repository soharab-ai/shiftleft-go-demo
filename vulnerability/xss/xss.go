package xss

import (
	"fmt"
	"html"
	"html/template"
	"log"
	"net/http"
	"regexp"

	"github.com/julienschmidt/httprouter"

	"github.com/ShiftLeftSecurity/shiftleft-go-demo/util"
	// "github.com/ShiftLeftSecurity/shiftleft-go-demo/util/middleware"
	"github.com/ShiftLeftSecurity/shiftleft-go-demo/vulnerability/sqli"
)

type XSS struct {
	Name string
}

func New() XSS {
	return XSS{}
}
func (XSS) SetRouter(r *httprouter.Router) {
	// mw := middleware.New()
	// r.GET("/xss1", mw.LoggingMiddleware(mw.CapturePanic(mw.AuthCheck(xss1Handler))))
	// r.POST("/xss1", mw.LoggingMiddleware(mw.CapturePanic(mw.AuthCheck(xss1Handler))))
	// r.GET("/xss2", mw.LoggingMiddleware(mw.CapturePanic(mw.AuthCheck(xss2Handler))))
	r.GET("/xss1", xss1Handler)
	r.POST("/xss1", xss1Handler)
	r.GET("/xss2", xss2Handler)
}

func xss1Handler(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {
	// Add Content Security Policy header for defense-in-depth protection
	w.Header().Set("Content-Security-Policy", "default-src 'self'; script-src 'self'")
	
	data := make(map[string]interfacenull)

	if r.Method == "GET" {
		// Extract user input
		term := r.FormValue("term")
		
		// Validate input before processing
		term = validateAndSanitizeInput(term)
		
		// Create structured data object instead of formatting HTML directly
		termData := struct {
			RawTerm    string
			IsEmpty    bool
			IsNotFound bool
			HasDetails bool
			Details    string
		}{
			RawTerm: term,
			IsEmpty: term == "",
		}
		
		// Business logic
		if term == "sql injection" {
			term = "sqli"
			termData.RawTerm = term
		}

		vulnDetails := GetExp(term)
		
		// Set structured flags based on results
		termData.IsNotFound = (term != "" && vulnDetails == "")
		termData.HasDetails = (vulnDetails != "")
		termData.Details = vulnDetails
		
		// Store structured data instead of formatted strings
		data["termData"] = termData
		data["rawTerm"] = term // Raw term for search input value
	}
	
	data["title"] = "Cross Site Scripting"
	
	// Create and execute a template with proper context-aware escaping
	tmpl := template.Must(template.New("xss1").Parse(`
		<!DOCTYPE html>
		<html>
		<head>
			<title>{{.title}}</title>
		</head>
		<body>
			<h1>{{.title}}</h1>
			<form method="GET">
				<input type="text" name="term" value="{{.rawTerm}}">
				<input type="submit" value="Search">
			</form>
			
			{{with .termData}}
				{{if .IsEmpty}}
					<!-- No search performed yet -->
				{{else if .IsNotFound}}
					<div><b><i>{{.RawTerm}}</i></b> not found</div>
				{{else if .HasDetails}}
					<div><b>{{.RawTerm}}</b></div>
					<div>{{.Details}}</div>
				{{end}}
			{{end}}
		</body>
		</html>
	`))
	
	// Let template system handle proper escaping based on context
	err := tmpl.Execute(w, data)
	if err != nil {
		http.Error(w, "Template execution error", http.StatusInternalServerError)
	}
}


func xss2Handler(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {
	uid := r.FormValue("uid")

	if util.CheckLevel(r) { // level = high
		uid = HTMLEscapeString(uid)
	}

	p := sqli.NewProfile() // using sqli get profile module instead of create new function
	err := p.SafeQueryGetData(uid)

	if err != nil {
		log.Println(err.Error())
	}

	data := make(map[string]interface{})

	js := ` <script>
			var id = %s
			var name = "%s"
			var city = "%s"
			var number = "%s"
			</script>` // here is the mistake, render value to a javascript that came from client request

	inlineJS := fmt.Sprintf(js, uid, p.Name, p.City, p.PhoneNumber)

	data["title"] = "Cross Site Scripting"

	data["inlineJS"] = template.HTML(inlineJS) // this will render the javascript on client browser

	util.SafeRender(w, r, "template.xss2", data)
}

func HTMLEscapeString(text string) string {
	filter := regexp.MustCompile("<[^>]*>")
	output := filter.ReplaceAllString(text, "")
	return html.EscapeString(output)
}

func removeScriptTag(text string) string {
	// This function is deprecated and replaced with validateAndSanitizeInput
	return validateAndSanitizeInput(text)
}

// validateAndSanitizeInput performs context-aware validation and sanitization
func validateAndSanitizeInput(input string) string {
	// Input validation - reject suspicious patterns before processing
	if containsMaliciousPatterns(input) {
		return "Invalid input"
	}
	
	// Custom bluemonday policy tailored to application requirements
	p := bluemonday.NewPolicy()
	
	// Allow only specific elements needed for this application
	p.AllowElements("b", "i", "strong", "em")
	
	// Allow specific attributes on specific elements
	p.AllowAttrs("href").OnElements("a")
	p.AllowURLSchemes("http", "https")
	
	// Ensure URLs are properly checked
	p.RequireNoReferrerOnLinks(true)
	p.RequireParseableURLs(true)
	
	// Apply the policy to sanitize the input
	return p.Sanitize(input)
}

// containsMaliciousPatterns checks for potentially malicious input patterns
func containsMaliciousPatterns(input string) bool {
	// Check for common XSS patterns
	suspiciousPatterns := []string{
		`(?i)<script`,
		`(?i)javascript:`,
		`(?i)data:text/html`,
		`(?i)onw+=`,
		`(?i)eval(`,
	}
	
	for _, pattern := range suspiciousPatterns {
		matched, _ := regexp.MatchString(pattern, input)
		if matched {
			return true
		}
	}
	
	return false
}

