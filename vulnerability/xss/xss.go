package xss

import (
	"fmt"
	"html"
	"html/template"
	"log"
	"net/http"
	"regexp"

	"github.com/julienschmidt/httprouter"

	"github.com/ShiftLeftSecurity/shiftleft-go-demo/util"
	// "github.com/ShiftLeftSecurity/shiftleft-go-demo/util/middleware"
	"github.com/ShiftLeftSecurity/shiftleft-go-demo/vulnerability/sqli"
)

type XSS struct {
	Name string
}

func New() XSS {
	return XSS{}
}
func (XSS) SetRouter(r *httprouter.Router) {
	// mw := middleware.New()
	// r.GET("/xss1", mw.LoggingMiddleware(mw.CapturePanic(mw.AuthCheck(xss1Handler))))
	// r.POST("/xss1", mw.LoggingMiddleware(mw.CapturePanic(mw.AuthCheck(xss1Handler))))
	// r.GET("/xss2", mw.LoggingMiddleware(mw.CapturePanic(mw.AuthCheck(xss2Handler))))
	r.GET("/xss1", xss1Handler)
	r.POST("/xss1", xss1Handler)
	r.GET("/xss2", xss2Handler)
}

func xss1Handler(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {
// TemplateData defines a strict structure for template data instead of using a generic map
type TemplateData struct {
	Title       string
	Term        string
	IsTermEmpty bool
	TermFound   bool
	VulnDetails string
}

func xss1Handler(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {
	// Create a strict data structure instead of a generic map
	data := TemplateData{
		Title: "Cross Site Scripting",
	}
	
	// Create a policy for sanitizing user input
	p := bluemonday.UGCPolicy()
	
	if r.Method == "GET" {
		term := r.FormValue("term")
		
		// Always sanitize input early
		sanitizedTerm := p.Sanitize(term)
		data.Term = sanitizedTerm
		data.IsTermEmpty = sanitizedTerm == ""
		
		// Special case handling without HTML construction
		if sanitizedTerm == "sql injection" {
			data.Term = "sqli"
			sanitizedTerm = "sqli"
		}
		
		// Get details without constructing HTML
		vulnDetails := GetExp(sanitizedTerm)
		data.VulnDetails = vulnDetails
		data.TermFound = vulnDetails != ""
	}
	
	// Enhanced CSP header with additional protections
	w.Header().Set("Content-Security-Policy", 
		"default-src 'self'; script-src 'self'; object-src 'none'; style-src 'self'; "+
		"img-src 'self'; base-uri 'none'; form-action 'self'")
	
	// Add X-XSS-Protection header for older browsers
	w.Header().Set("X-XSS-Protection", "1; mode=block")
	
	// Render template using html/template to ensure proper escaping
	renderTemplate(w, "template.xss1", data)
}

// renderTemplate safely renders templates using html/template package
func renderTemplate(w http.ResponseWriter, tmplName string, data interfacenull) {
	// Replace the previous util.SafeRender with a known-safe implementation
	tmpl, err := template.ParseFiles("templates/" + tmplName + ".gohtml")
	if err != nil {
		http.Error(w, "Template error", http.StatusInternalServerError)
		return
	}
	
	err = tmpl.Execute(w, data)
	if err != nil {
		http.Error(w, "Template rendering error", http.StatusInternalServerError)
	}
}

			data["term"] = ""
		} else if vulnDetails == "" {
			data["value"] = sanitizedTerm
			data["notFound"] = true  // Template will format this appropriately
			data["searchTerm"] = sanitizedTerm
		} else {
			data["value"] = sanitizedTerm
			data["searchTerm"] = sanitizedTerm
			data["details"] = vulnDetails
		}
	}
	
func removeScriptTag(text string) string {
	// Use different policies for different contexts
	p := bluemonday.UGCPolicy()
	// Add additional protections specifically for script contexts
	p.AllowElements("p", "br", "span", "b", "i", "u", "strong", "em")
	p.AllowAttributes("class").OnElements("p", "span")
	// Explicitly disallow all other elements/attributes
	return p.Sanitize(text)
}

		log.Printf("Template rendering error: %v", err)
		http.Error(w, "Internal server error", http.StatusInternalServerError)
	}
}

func xss2Handler(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {
	uid := r.FormValue("uid")

	if util.CheckLevel(r) { // level = high
		uid = HTMLEscapeString(uid)
	}

	p := sqli.NewProfile() // using sqli get profile module instead of create new function
	err := p.SafeQueryGetData(uid)

	if err != nil {
		log.Println(err.Error())
	}

	data := make(map[string]interface{})

	js := ` <script>
// sanitizeInputStrict uses bluemonday to comprehensively sanitize user input
// by removing all HTML/script elements
func sanitizeInputStrict(input string) string {
	// Use bluemonday's StrictPolicy which removes all HTML tags
	p := bluemonday.StrictPolicy()
	return p.Sanitize(input)
// sanitizeInputUGC uses bluemonday to sanitize user input
// while allowing limited safe HTML formatting elements
func sanitizeInputUGC(input string) string {
	// Use UGCPolicy for cases where some HTML formatting is allowed
	p := bluemonday.UGCPolicy()
	
	// Customize allowed elements for limited formatting
	p.AllowElements("b", "i", "em", "strong")
	
	return p.Sanitize(input)
}
// RegisterTemplateFunctions creates and returns custom template functions
// for different encoding contexts
func RegisterTemplateFunctions() template.FuncMap {
	return template.FuncMap{
		// These functions can be used in templates for context-specific encoding
		"htmlattr": html.EscapeString,
		"jsstr": template.JSEscapeString,
		"urlquery": url.QueryEscape,
		
		// Allow some safe HTML with the UGC policy
		"safehtml": sanitizeInputUGC,
	}
}

	}
	
	// Apply sanitization with error handling
	sanitized := htmlPolicy.Sanitize(text)
	
	// Additional validation for script-like content that might bypass sanitization
	if strings.Contains(strings.ToLower(sanitized), "script") || 
	   strings.Contains(strings.ToLower(sanitized), "onerror") ||
	   strings.Contains(strings.ToLower(sanitized), "javascript:") {
		log.Printf("Potentially dangerous content detected after sanitization: %s", strictPolicy.Sanitize(text))
		return "[Content removed for security]"
	}
	
	return sanitized
}

