package xss

import (
	"fmt"
	"html"
	"html/template"
	"log"
	"net/http"
	"regexp"

	"github.com/julienschmidt/httprouter"

	"github.com/ShiftLeftSecurity/shiftleft-go-demo/util"
	// "github.com/ShiftLeftSecurity/shiftleft-go-demo/util/middleware"
	"github.com/ShiftLeftSecurity/shiftleft-go-demo/vulnerability/sqli"
)

type XSS struct {
	Name string
}

func New() XSS {
	return XSS{}
}
func (XSS) SetRouter(r *httprouter.Router) {
	// mw := middleware.New()
	// r.GET("/xss1", mw.LoggingMiddleware(mw.CapturePanic(mw.AuthCheck(xss1Handler))))
	// r.POST("/xss1", mw.LoggingMiddleware(mw.CapturePanic(mw.AuthCheck(xss1Handler))))
	// r.GET("/xss2", mw.LoggingMiddleware(mw.CapturePanic(mw.AuthCheck(xss2Handler))))
	r.GET("/xss1", xss1Handler)
	r.POST("/xss1", xss1Handler)
	r.GET("/xss2", xss2Handler)
}

func xss1Handler(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {
	// Add Content Security Policy header for additional protection
	w.Header().Set("Content-Security-Policy", "default-src 'self'; script-src 'self'; object-src 'none';")
	
	data := make(map[string]interfacenull)
	data["title"] = "Cross Site Scripting"

	if r.Method == "GET" {
		term := r.FormValue("term")
		
		// Always sanitize input - use plaintext sanitization for term
		sanitizedTerm := sanitizeInputStrict(term)
		
		// Store the plaintext version for use in text contexts
		data["term_plaintext"] = sanitizedTerm
		
		// Boolean flag for template logic instead of conditionally formatting HTML
		data["term_empty"] = (sanitizedTerm == "")

		if sanitizedTerm == "sql injection" {
			sanitizedTerm = "sqli"
		}

		vulnDetails := GetExp(sanitizedTerm)
		
		// Store boolean flag for template logic
		data["is_found"] = (vulnDetails != "")
		
		// Store the search term and results as plaintext
		data["search_term"] = sanitizedTerm
		data["search_results"] = vulnDetails
	}
	
	util.SafeRender(w, r, "template.xss1", data)
}


		// Pass raw data to template without HTML construction in code
		if term == "" {
			data["term"] = ""
		} else if vulnDetails == "" {
			data["value"] = sanitizedTerm
			data["notFound"] = true  // Template will format this appropriately
			data["searchTerm"] = sanitizedTerm
		} else {
			data["value"] = sanitizedTerm
			data["searchTerm"] = sanitizedTerm
			data["details"] = vulnDetails
		}
	}
	
	data["title"] = "Cross Site Scripting"
	
	// Error handling for template rendering
	err := util.SafeRender(w, r, "template.xss1", data)
	if err != nil {
		log.Printf("Template rendering error: %v", err)
		http.Error(w, "Internal server error", http.StatusInternalServerError)
	}
}

func xss2Handler(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {
	uid := r.FormValue("uid")

	if util.CheckLevel(r) { // level = high
		uid = HTMLEscapeString(uid)
	}

	p := sqli.NewProfile() // using sqli get profile module instead of create new function
	err := p.SafeQueryGetData(uid)

	if err != nil {
		log.Println(err.Error())
	}

	data := make(map[string]interface{})

	js := ` <script>
// sanitizeInputStrict uses bluemonday to comprehensively sanitize user input
// by removing all HTML/script elements
func sanitizeInputStrict(input string) string {
	// Use bluemonday's StrictPolicy which removes all HTML tags
	p := bluemonday.StrictPolicy()
	return p.Sanitize(input)
// sanitizeInputUGC uses bluemonday to sanitize user input
// while allowing limited safe HTML formatting elements
func sanitizeInputUGC(input string) string {
	// Use UGCPolicy for cases where some HTML formatting is allowed
	p := bluemonday.UGCPolicy()
	
	// Customize allowed elements for limited formatting
	p.AllowElements("b", "i", "em", "strong")
	
	return p.Sanitize(input)
}
// RegisterTemplateFunctions creates and returns custom template functions
// for different encoding contexts
func RegisterTemplateFunctions() template.FuncMap {
	return template.FuncMap{
		// These functions can be used in templates for context-specific encoding
		"htmlattr": html.EscapeString,
		"jsstr": template.JSEscapeString,
		"urlquery": url.QueryEscape,
		
		// Allow some safe HTML with the UGC policy
		"safehtml": sanitizeInputUGC,
	}
}

	}
	
	// Apply sanitization with error handling
	sanitized := htmlPolicy.Sanitize(text)
	
	// Additional validation for script-like content that might bypass sanitization
	if strings.Contains(strings.ToLower(sanitized), "script") || 
	   strings.Contains(strings.ToLower(sanitized), "onerror") ||
	   strings.Contains(strings.ToLower(sanitized), "javascript:") {
		log.Printf("Potentially dangerous content detected after sanitization: %s", strictPolicy.Sanitize(text))
		return "[Content removed for security]"
	}
	
	return sanitized
}

