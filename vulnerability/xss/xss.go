package xss

import (
	"fmt"
	"html"
	"html/template"
	"log"
	"net/http"
	"regexp"

	"github.com/julienschmidt/httprouter"

	"github.com/ShiftLeftSecurity/shiftleft-go-demo/util"
	// "github.com/ShiftLeftSecurity/shiftleft-go-demo/util/middleware"
	"github.com/ShiftLeftSecurity/shiftleft-go-demo/vulnerability/sqli"
)

type XSS struct {
	Name string
}

func New() XSS {
	return XSS{}
}
func (XSS) SetRouter(r *httprouter.Router) {
	// mw := middleware.New()
	// r.GET("/xss1", mw.LoggingMiddleware(mw.CapturePanic(mw.AuthCheck(xss1Handler))))
	// r.POST("/xss1", mw.LoggingMiddleware(mw.CapturePanic(mw.AuthCheck(xss1Handler))))
	// r.GET("/xss2", mw.LoggingMiddleware(mw.CapturePanic(mw.AuthCheck(xss2Handler))))
	r.GET("/xss1", xss1Handler)
	r.POST("/xss1", xss1Handler)
	r.GET("/xss2", xss2Handler)
}

func xss1Handler(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {
// CSRF token store with mutex for thread safety
var (
	csrfTokens     = make(map[string]time.Time)
	csrfTokenMutex sync.RWMutex
)

// Generate secure random CSRF token
func generateCSRFToken() string {
	b := make([]byte, 32)
	_, err := rand.Read(b)
	if err != nil {
		return ""
	}
	return base64.StdEncoding.EncodeToString(b)
}

// Validate CSRF token
func validateCSRFToken(token string, r *http.Request) bool {
	csrfTokenMutex.RLock()
	defer csrfTokenMutex.RUnlock()
	
	expiryTime, exists := csrfTokens[token]
	if !exists {
		return false
	}
	
	// Check if token is expired (30 minutes validity)
	if time.Now().After(expiryTime) {
		delete(csrfTokens, token)
		return false
	}
	
	return true
}

// CSRF protection middleware
func csrfProtection(next httprouter.Handle) httprouter.Handle {
	return func(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
		// Skip CSRF check for GET requests
		if r.Method != "GET" {
			token := r.Header.Get("X-CSRF-Token")
			if !validateCSRFToken(token, r) {
				http.Error(w, "Invalid CSRF token", http.StatusForbidden)
				return
			}
		}
		
		// For GET requests, generate and set a new token
		if r.Method == "GET" {
			token := generateCSRFToken()
			csrfTokenMutex.Lock()
			csrfTokens[token] = time.Now().Add(30 * time.Minute)
			csrfTokenMutex.Unlock()
			
			// Set token in cookie
			cookie := http.Cookie{
				Name:     "csrf_token",
				Value:    token,
				HttpOnly: true,
				Secure:   true, // Require HTTPS
				SameSite: http.SameSiteStrictMode,
				Path:     "/",
				MaxAge:   1800, // 30 minutes
			}
			http.SetCookie(w, &cookie)
		}
		
		next(w, r, ps)
	}
}

// Context-specific sanitization function
func sanitizeUserInput(input string, context string) string {
	var p *bluemonday.Policy
	
	switch context {
	case "search":
		p = bluemonday.StrictPolicy() // Most restrictive for search terms
	case "comment":
		p = bluemonday.UGCPolicy()    // Allow formatting in comments
	case "html":
		// Custom policy allowing some HTML but being strict
		p = bluemonday.NewPolicy()
		p.AllowElements("b", "i", "em", "strong")
		p.AllowStandardURLs()
	default:
		p = bluemonday.StrictPolicy() // Default to strict
	}
	
	return p.Sanitize(input)
}

func xss1Handler(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {
	// Add security headers
	w.Header().Set("Content-Security-Policy", "default-src 'self'; script-src 'self'; object-src 'none'")
	w.Header().Set("Content-Type", "text/html; charset=utf-8")
	w.Header().Set("X-XSS-Protection", "1; mode=block")
	w.Header().Set("X-Content-Type-Options", "nosniff")
	
	data := make(map[string]interfacenull)

	if r.Method == "GET" {
		term := r.FormValue("term")
		
		// Apply strict sanitization for search term context
		term = sanitizeUserInput(term, "search")
		
		// Apply additional HTML escaping for high security level
		if util.CheckLevel(r) { // level = high
			term = template.HTMLEscapeString(term)
		}

		// Handle special cases after sanitization
		if term == "sql injection" {
			term = "sqli"
		}

		vulnDetails := GetExp(term)
		
		// Just pass sanitized data to template - no HTML concatenation here
		data["searchTerm"] = term
		data["hasResults"] = false
		
		if term != "" {
			if vulnDetails == "" {
				data["noResults"] = true
			} else {
				data["hasResults"] = true
				data["details"] = sanitizeUserInput(vulnDetails, "html")
			}
		}
	}
	
	data["title"] = "Cross Site Scripting"
	data["csrfToken"] = r.URL.Query().Get("csrf_token")
	
	// Use SafeRender which we assume is properly implemented to use html/template
	util.SafeRender(w, r, "template.xss1", data)
}

// Updated SafeRender function to be placed in the util package
func SafeRender(w http.ResponseWriter, r *http.Request, templateName string, data map[string]interfacenull) {
	tmpl := template.New(templateName).Funcs(template.FuncMap{
		"safeHTML": func(s string) template.HTML {
			// Only use for trusted content that absolutely needs HTML
			return template.HTML(s)
		},
	})
	
	// Always use proper contextual auto-escaping
	tmpl = template.Must(tmpl.ParseFiles("templates/" + templateName + ".html"))
	tmpl.Execute(w, data)
}

func xss2Handler(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {
	uid := r.FormValue("uid")

	if util.CheckLevel(r) { // level = high
		uid = HTMLEscapeString(uid)
	}

	p := sqli.NewProfile() // using sqli get profile module instead of create new function
	err := p.SafeQueryGetData(uid)

	if err != nil {
		log.Println(err.Error())
	}

	data := make(map[string]interface{})

	js := ` <script>
			var id = %s
			var name = "%s"
			var city = "%s"
			var number = "%s"
			</script>` // here is the mistake, render value to a javascript that came from client request

	inlineJS := fmt.Sprintf(js, uid, p.Name, p.City, p.PhoneNumber)

	data["title"] = "Cross Site Scripting"

	data["inlineJS"] = template.HTML(inlineJS) // this will render the javascript on client browser

	util.SafeRender(w, r, "template.xss2", data)
}

func HTMLEscapeString(text string) string {
	filter := regexp.MustCompile("<[^>]*>")
	output := filter.ReplaceAllString(text, "")
	return html.EscapeString(output)
}

func removeScriptTag(text string) string {
	// Using bluemonday with a policy specifically for HTML content
	p := bluemonday.NewPolicy()
	
	// Allow a limited set of HTML elements but no scripts
	p.AllowElements("p", "br", "b", "i", "em", "strong", "a", "ul", "ol", "li")
	
	// Allow specific attributes on links
	p.AllowAttrs("href").OnElements("a")
	
	// Ensure links are properly formed
	p.RequireParseableURLs(true)
	p.RequireNoFollowOnLinks(true)
	p.AllowRelativeURLs(true)
	p.AllowURLSchemes("http", "https")
	
	return p.Sanitize(text)
}

