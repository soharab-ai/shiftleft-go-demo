package sqli

import(
	"log"
	"fmt"
	"database/sql"

	"github.com/ShiftLeftSecurity/shiftleft-go-demo/util/database"
)

var DB *sql.DB
var err error

func init(){
	DB, err = database.Connect()
	if err != nil{
		log.Println(err.Error())
	}
}

type Profile struct{
	Uid int
	Name string
	City string
	PhoneNumber string
}

func NewProfile()*Profile{
	return &Profile{}
}

func(p *Profile)UnsafeQueryGetData(uid string)error{
// UserRole represents user's permission level
type UserRole int

const (
    RoleGuest UserRole = iota
    RoleUser
    RoleAdmin
)

// ProfileModel is the GORM model for profile data
type ProfileModel struct {
    UserID      int    `gorm:"column:user_id"`
    FullName    string `gorm:"column:full_name"`
    City        string `gorm:"column:city"`
    PhoneNumber string `gorm:"column:phone_number"`
}

// TableName specifies the table name for GORM
func (ProfileModel) TableName() string {
    return "Profile"
}

// WhitelistedQueries contains the approved query templates
var WhitelistedQueries = map[string]bool{
    "SELECT p.user_id, p.full_name, p.city, p.phone_number FROM Profile as p, Users as u where p.user_id = u.id and u.id=?": true,
}

// DB connection pool configuration
func initDBPool(db *sql.DB) {
    // Limit the number of idle connections to prevent resource exhaustion
    db.SetMaxIdleConns(10)
    // Limit the number of open connections
    db.SetMaxOpenConns(100)
    // Set connection lifetime
    db.SetConnMaxLifetime(5 * time.Minute)
    // Set idle connection timeout
    db.SetConnMaxIdleTime(2 * time.Minute)
}

// SafeQueryGetData replaces UnsafeQueryGetData with secure implementation
func(p *Profile)SafeQueryGetData(uid string)error{
    // Create context with timeout to prevent long-running queries
    ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
    defer cancel()
    
    // Initialize sanitizer for input data
    sanitizer := bluemonday.StrictPolicy()
    sanitizedUID := sanitizer.Sanitize(uid)
    
    // Role-based access control check
    if !hasPermission(ctx, sanitizedUID, RoleUser) {
        return fmt.Errorf("access denied: insufficient permissions")
    }
    
    // Validate the sanitized input UID
    validID, err := validateUID(sanitizedUID)
    if err != nil {
        log.Printf("Invalid UID format: %s", sanitizer.Sanitize(err.Error()))
        return fmt.Errorf("invalid user ID format")
    }
    
    // Option 1: Using GORM (ORM layer)
    db, err := gorm.Open(mysql.Open(DBConnectionString), &gorm.Confignull)
    if err != nil {
        log.Printf("Database connection error: %s", sanitizer.Sanitize(err.Error()))
        return fmt.Errorf("database connection error")
    }
    sqlDB, _ := db.DB()
    defer sqlDB.Close()
    
    // Configure connection pool
    initDBPool(sqlDB)
    
    var profile ProfileModel
    result := db.Where("user_id = ?", validID).First(&profile)
    if result.Error != nil {
        if result.Error == gorm.ErrRecordNotFound {
            return fmt.Errorf("no matching records found")
        }
        log.Printf("Database query error: %s", sanitizer.Sanitize(result.Error.Error()))
        return fmt.Errorf("database error occurred")
    }
    
    // Map the GORM model to our Profile struct
    p.Uid = profile.UserID
    p.Name = profile.FullName
    p.City = profile.City
    p.PhoneNumber = profile.PhoneNumber
    
    // Option 2: Using prepared statements with context (as an alternative to GORM)
    /*
    // Query whitelisting check
    getProfileSql := `SELECT p.user_id, p.full_name, p.city, p.phone_number 
                    FROM Profile as p, Users as u 
                    where p.user_id = u.id 
                    and u.id=?` 
                    
    if !WhitelistedQueries[getProfileSql] {
        log.Printf("Rejected non-whitelisted query attempt")
        return fmt.Errorf("security error: unauthorized query pattern")
    }
    
    // Use prepared statement with context
    stmt, err := DB.PrepareContext(ctx, getProfileSql)
    if err != nil {
        log.Printf("Statement preparation error: %s", sanitizer.Sanitize(err.Error()))
        return fmt.Errorf("database error occurred")
    }
    defer stmt.Close()
    
    rows, err := stmt.QueryContext(ctx, validID)
    if err != nil {
        log.Printf("Database query error: %s", sanitizer.Sanitize(err.Error()))
        return fmt.Errorf("database error occurred")
    }
    defer rows.Close()
    
    foundRecord := false
    for rows.Next() {
        foundRecord = true
        err = rows.Scan(&p.Uid, &p.Name, &p.City, &p.PhoneNumber)
        if err != nil {
            log.Printf("Row scan error: %s", sanitizer.Sanitize(err.Error()))
            return fmt.Errorf("data processing error occurred")
        }
    }
    
    if !foundRecord {
        return fmt.Errorf("no matching records found")
    }
    */
    
    return nil
}

// hasPermission checks if the user has the required role
func hasPermission(ctx context.Context, userID string, requiredRole UserRole) bool {
    // In a real application, this would fetch the user's role from a database or authentication service
    // For this example, we'll assume all valid users have at least RoleUser permission
    id, err := strconv.Atoi(userID)
    if err != nil || id <= 0 {
        return false
    }
    return true
}

func(p *Profile)SafeQueryGetData(uid string) error{

	/* this funciton use to get data Profile from database with prepare statement */

	const (
		getProfileSql = 
		`SELECT p.user_id, p.full_name, p.city, p.phone_number 
		FROM Profile as p,Users as u 
		where p.user_id = u.id 
		and u.id=?`) 
	
	stmt, err := DB.Prepare(getProfileSql) //prepare statement 
	if err != nil{
		return err
	}

	defer stmt.Close()
	err = stmt.QueryRow(uid).Scan(&p.Uid,&p.Name,&p.City,&p.PhoneNumber)
	if err != nil{
		return err
	}
	return nil
}
