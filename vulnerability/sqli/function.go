package sqli

import(
	"log"
	"fmt"
	"database/sql"

	"github.com/ShiftLeftSecurity/shiftleft-go-demo/util/database"
)

var DB *sql.DB
var err error

func init(){
	DB, err = database.Connect()
	if err != nil{
		log.Println(err.Error())
	}
}

type Profile struct{
	Uid int
	Name string
	City string
	PhoneNumber string
}

func NewProfile()*Profile{
	return &Profile{}
}

func(p *Profile)UnsafeQueryGetData(uid string)error{
	/* this function gets Profile data from database with enhanced SQL injection protection */

	// Enhanced validation - only allow numeric IDs within reasonable length
	// Added more comprehensive validation beyond just numeric check
	if !isValidUserID(uid) {
		log.Printf("Invalid user ID format or length: %s", uid)
		return errors.New("invalid user ID format")
	}
	
	// Create context with timeout to prevent long-running malicious queries
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()
	
	// Use prepared statement instead of direct query for better protection
	getProfileSql := `SELECT p.user_id, p.full_name, p.city, p.phone_number 
					FROM Profile as p 
					JOIN Users as u ON p.user_id = u.id 
					WHERE u.id = ?`
	
	// Prepare the statement for better performance and security
	stmt, err := DB.PrepareContext(ctx, getProfileSql)
	if err != nil {
		log.Printf("Statement preparation error: %s", err.Error())
		return errors.New("database error occurred")
	}
	defer stmt.Close()
	
	// Execute query with context and parameters
	rows, err := stmt.QueryContext(ctx, uid)
	if err != nil {
		log.Printf("Query execution error: %s", err.Error())
		return errors.New("database error occurred")
	}
	defer rows.Close()
	
	found := false
	for rows.Next() {
		found = true
		err = rows.Scan(&p.Uid, &p.Name, &p.City, &p.PhoneNumber)
		if err != nil {
			log.Printf("Data scan error: %s", err.Error())
			return errors.New("error processing data")
		}
	}
	
	// Check for any errors during row iteration
	if err = rows.Err(); err != nil {
		log.Printf("Row iteration error: %s", err.Error())
		return errors.New("error retrieving data")
	}
	
	if !found {
		return errors.New("no data found")
	}
	
	return nil
}

// Helper function for comprehensive validation
func isValidUserID(uid string) bool {
	// Check that ID is numeric
	if _, err := strconv.Atoi(uid); err != nil {
		return false
	}
	
	// Additional validations
	// Ensure reasonable length (e.g., max 10 digits for user IDs)
	if len(uid) > 10 || len(uid) == 0 {
		return false
	}
	
	// Ensure it only contains digits (more strict than strconv.Atoi)
	match, _ := regexp.MatchString("^[0-9]+$", uid)
	return match
}

// Init function should be added to ensure proper database connection pooling
func init() {
	// Configure connection pool settings to prevent DoS attacks
	if DB != nil {
		// Set maximum open connections
		DB.SetMaxOpenConns(25)
		
		// Set maximum idle connections
		DB.SetMaxIdleConns(5)
		
		// Set connection lifetime
		DB.SetConnMaxLifetime(5 * time.Minute)
		
		// Set connection idle time
		DB.SetConnMaxIdleTime(1 * time.Minute)
	}
}

	return nil
}

func(p *Profile)SafeQueryGetData(uid string) error{

	/* this funciton use to get data Profile from database with prepare statement */

	const (
		getProfileSql = 
		`SELECT p.user_id, p.full_name, p.city, p.phone_number 
		FROM Profile as p,Users as u 
		where p.user_id = u.id 
		and u.id=?`) 
	
	stmt, err := DB.Prepare(getProfileSql) //prepare statement 
	if err != nil{
		return err
	}

	defer stmt.Close()
	err = stmt.QueryRow(uid).Scan(&p.Uid,&p.Name,&p.City,&p.PhoneNumber)
	if err != nil{
		return err
	}
	return nil
}
