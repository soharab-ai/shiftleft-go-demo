package sqli

import(
	"log"
	"fmt"
	"database/sql"

	"github.com/ShiftLeftSecurity/shiftleft-go-demo/util/database"
)

var DB *sql.DB
var err error

func init(){
	DB, err = database.Connect()
	if err != nil{
		log.Println(err.Error())
	}
}

type Profile struct{
	Uid int
	Name string
	City string
	PhoneNumber string
}

func NewProfile()*Profile{
	return &Profile{}
}

func(p *Profile)UnsafeQueryGetData(uid string)error{
	/* this function gets data Profile from database with secure query */
	
	// Added input validation before executing query
	if !isValidUID(uid) {
		return fmt.Errorf("invalid user ID format")
	}

	// Added context with timeout for better request handling
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	// Implemented query builder for more robust SQL construction
	query := squirrel.Select("p.user_id", "p.full_name", "p.city", "p.phone_number").
		From("Profile AS p").
		Join("Users AS u ON p.user_id = u.id").
		Where(squirrel.Eq{"u.id": uid})
	
	sql, args, err := query.ToSql()
	if err != nil {
		log.Printf("SQL generation error: %s", err.Error())
		return fmt.Errorf("database error occurred")
	}

	// Using explicit prepared statements instead of direct parameterized queries
	stmt, err := DB.PrepareContext(ctx, sql)
	if err != nil {
		log.Printf("Statement preparation error: %s", err.Error())
		return fmt.Errorf("database error occurred")
	}
	defer stmt.Close()
	
	// Using context-aware query execution
	rows, err := stmt.QueryContext(ctx, args...)
	if err != nil {
		log.Printf("Database query error: %s", err.Error())
		return fmt.Errorf("database error occurred")
	}
	defer rows.Close()
	
	found := false
	for rows.Next() {
		found = true
		err = rows.Scan(&p.Uid, &p.Name, &p.City, &p.PhoneNumber)
		if err != nil {
			log.Printf("Row scan error: %s", err.Error())
			return fmt.Errorf("error processing results")
		}
	}
	
	// Check for errors from iterating over rows
	if err = rows.Err(); err != nil {
		log.Printf("Row iteration error: %s", err.Error())
		return fmt.Errorf("error processing results")
	}
	
	if !found {
		return fmt.Errorf("no data found")
	}
	
	return nil
}

// Helper function for input validation
func isValidUID(uid string) bool {
	// Basic validation: UID should be alphanumeric and reasonable length
	match, _ := regexp.MatchString("^[a-zA-Z0-9]{1,64}$", uid)
	return match
}

// During application initialization, configure connection pooling
func initDB() {
	// Assuming DB is a *sql.DB instance
	DB.SetMaxOpenConns(25)
	DB.SetMaxIdleConns(5)
	DB.SetConnMaxLifetime(5 * time.Minute)
}

	
	// Ensure transaction is rolled back if error occurs
	defer func() {
		if err != nil {
			tx.Rollback()
		}
	}()
	
	getProfileSql := `SELECT p.user_id, p.full_name, p.city, p.phone_number 
					FROM Profile as p, Users as u 
					WHERE p.user_id = u.id 
					AND u.id=?`
					
	// Use prepared statement with context
	stmt, err := tx.PrepareContext(ctx, getProfileSql)
	if err != nil {
		log.Printf("Failed to prepare statement: %s", err.Error())
		return fmt.Errorf("database error")
	}
	defer stmt.Close()
	
	rows, err := stmt.QueryContext(ctx, uid)
	if err != nil{
		// Log the actual error but return a generic message to the client
		log.Printf("Database query error: %s", err.Error())
		return fmt.Errorf("failed to retrieve profile data")
	}
	defer rows.Close()

	dataFound := false
	for rows.Next(){
		err = rows.Scan(&p.Uid, &p.Name, &p.City, &p.PhoneNumber)
		if err != nil{
			log.Printf("Row scan error: %s", err.Error())
			return fmt.Errorf("error processing profile data")
		}
		dataFound = true
	}
	
	if err = rows.Err(); err != nil {
		log.Printf("Error iterating rows: %s", err.Error())
		return fmt.Errorf("error processing profile data")
	}
	
	// Commit transaction if everything succeeded
	err = tx.Commit()
	if err != nil {
		log.Printf("Failed to commit transaction: %s", err.Error())
		return fmt.Errorf("database error")
	}
	
	if !dataFound {
		return fmt.Errorf("no data found")
	}
	
	return nil
}

	return nil
}

func(p *Profile)SafeQueryGetData(uid string) error{

	/* this funciton use to get data Profile from database with prepare statement */

	const (
		getProfileSql = 
		`SELECT p.user_id, p.full_name, p.city, p.phone_number 
		FROM Profile as p,Users as u 
		where p.user_id = u.id 
		and u.id=?`) 
	
	stmt, err := DB.Prepare(getProfileSql) //prepare statement 
	if err != nil{
		return err
	}

	defer stmt.Close()
	err = stmt.QueryRow(uid).Scan(&p.Uid,&p.Name,&p.City,&p.PhoneNumber)
	if err != nil{
		return err
	}
	return nil
}
