package sqli

import(
	"log"
	"fmt"
	"database/sql"

	"github.com/ShiftLeftSecurity/shiftleft-go-demo/util/database"
)

var DB *sql.DB
var err error

func init(){
	DB, err = database.Connect()
	if err != nil{
		log.Println(err.Error())
	}
}

type Profile struct{
	Uid int
	Name string
	City string
	PhoneNumber string
}

func NewProfile()*Profile{
	return &Profile{}
}

func(p *Profile)UnsafeQueryGetData(uid string)error{
// Logger for SQL operations
var logger *Logger
var validate *validator.Validate

// Define allowed query templates
var allowedQueries = map[string]string{
    "profile_get": `SELECT p.user_id, p.full_name, p.city, p.phone_number 
                    FROM Profile as p, Users as u 
                    WHERE p.user_id = u.id 
                    AND u.id = ?`,
}

// Logger for monitoring SQL operations
type Logger struct {
    logFile *log.Logger
}

func NewLogger() *Logger {
    return &Logger{
        logFile: log.New(log.Writer(), "SQL_MONITOR: ", log.LstdFlags),
    }
}

func (l *Logger) LogQuery(queryName, queryTemplate string) {
    // Log query pattern (not parameters) for security monitoring
    l.logFile.Printf("Executing query pattern: %s, template: %s", queryName, queryTemplate)
}

func init() {
    // Initialize validator
    validate = validator.New()
    // Initialize logger
    logger = NewLogger()
    // In a real environment, this would use proper configuration
    // DB, err = sql.Open("mysql", "read_only_user:password@/database")
}

// isValidUID validates if the user ID follows the expected pattern
func isValidUID(uid string) bool {
    // Only allow alphanumeric user IDs
    match, _ := regexp.MatchString("^[a-zA-Z0-9]+$", uid)
    return match
}

// ExecuteWhitelistedQuery runs a query from the whitelist
func ExecuteWhitelistedQuery(queryName string, params ...interfacenull) (*sql.Rows, error) {
    queryTemplate, exists := allowedQueries[queryName]
    if !exists {
        return nil, fmt.Errorf("query template not in whitelist: %s", queryName)
    }
    
    // Log the query being executed (without parameters)
    logger.LogQuery(queryName, queryTemplate)
    
    // Execute query with parameters
    return DB.Query(queryTemplate, params...)
}

func(p *Profile)UnsafeQueryGetData(uid string)error{
    // This function now uses multiple security layers to prevent SQL injection
    
    // 1. Validate input format first
    if !isValidUID(uid) {
        return fmt.Errorf("invalid user ID format")
    }
    
    // 2. Use whitelisted query with parameterization
    rows, err := ExecuteWhitelistedQuery("profile_get", uid)
    if err != nil {
        // Secure logging - avoid including raw user input in error logs
        log.Printf("Database query error: %s", err.Error())
        return err
    }
    defer rows.Close()
    
    // 3. Process results with proper error handling
    foundData := false
    for rows.Next(){
        foundData = true
        err = rows.Scan(&p.Uid, &p.Name, &p.City, &p.PhoneNumber)
        if err != nil{
            log.Printf("Row scan error: %s", err.Error())
            return err
        }
    }
    
    // 4. Check for additional errors from iterating over rows
    if err = rows.Err(); err != nil {
        log.Printf("Row iteration error: %s", err.Error())
        return err
    }
    
    // 5. Validate we got expected data
    if !foundData {
        return fmt.Errorf("no data found for user ID")
    }
    
    return nil
}

// StoredProcQueryGetData uses stored procedures for additional security
func(p *Profile)StoredProcQueryGetData(uid string)error{
    // In a real implementation, this would call a stored procedure
    _, err := DB.Exec("CALL get_profile_data(?)", uid)
    if err != nil {
        log.Printf("Stored procedure error: %s", err.Error())
        return err
    }
    // Process results from stored procedure
    // (This is a simplified example)
    return nil
}

// OrmQueryGetData demonstrates using an ORM layer
func(p *Profile)OrmQueryGetData(uid string)error{
    // This is a simplified example of how an ORM would be used
    // In real code, proper ORM setup and error handling would be implemented
    db := gorm.DB
    type Result struct {
        UserID      string
        FullName    string
        City        string
        PhoneNumber string
    }
    
    var result Result
    if err := db.Raw("SELECT p.user_id, p.full_name, p.city, p.phone_number FROM Profile as p, Users as u WHERE p.user_id = u.id AND u.id = ?", uid).Scan(&result).Error; err != nil {
        return err
    }
    
    p.Uid = result.UserID
    p.Name = result.FullName
    p.City = result.City
    p.PhoneNumber = result.PhoneNumber
    
    return nil
}

func(p *Profile)SafeQueryGetData(uid string) error{

	/* this funciton use to get data Profile from database with prepare statement */

	const (
		getProfileSql = 
		`SELECT p.user_id, p.full_name, p.city, p.phone_number 
		FROM Profile as p,Users as u 
		where p.user_id = u.id 
		and u.id=?`) 
	
	stmt, err := DB.Prepare(getProfileSql) //prepare statement 
	if err != nil{
		return err
	}

	defer stmt.Close()
	err = stmt.QueryRow(uid).Scan(&p.Uid,&p.Name,&p.City,&p.PhoneNumber)
	if err != nil{
		return err
	}
	return nil
}
