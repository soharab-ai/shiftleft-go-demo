package sqli

import(
	"log"
	"fmt"
	"database/sql"

	"github.com/ShiftLeftSecurity/shiftleft-go-demo/util/database"
)

var DB *sql.DB
var err error

func init(){
	DB, err = database.Connect()
	if err != nil{
		log.Println(err.Error())
	}
}

type Profile struct{
	Uid int
	Name string
	City string
	PhoneNumber string
}

func NewProfile()*Profile{
	return &Profile{}
}

func(p *Profile)UnsafeQueryGetData(uid string)error{
	// Create context with timeout for database operations
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()
	
	logger := logrus.New()
	logger.SetFormatter(&logrus.JSONFormatternull)
	
	// Added input validation to ensure uid contains only numeric values
	if !regexp.MustCompile(`^[0-9]+$`).MatchString(uid) {
		// Added audit logging for failed validation attempts
		logger.WithFields(logrus.Fields{
			"action": "sql_injection_attempt",
			"input": uid,
			"remote_ip": "REMOTE_IP", // In a real implementation, capture the actual IP
		}).Warn("Invalid user ID format detected")
		return errors.New("invalid user ID format")
	}
	
	// Using parameterized query with placeholder instead of string concatenation
	getProfileSql := `SELECT p.user_id, p.full_name, p.city, p.phone_number 
					FROM Profile as p, Users as u 
					WHERE p.user_id = u.id 
					AND u.id=?`
	
	// Implemented prepared statement with explicit type binding
	stmt, err := DB.PrepareContext(ctx, getProfileSql)
	if err != nil {
		logger.WithError(err).Error("Failed to prepare SQL statement")
		return errors.New("database error occurred")
	}
	defer stmt.Close()
	
	// Use QueryContext instead of Query to allow for cancellation and timeout
	rows, err := stmt.QueryContext(ctx, uid)
	if err != nil {
		// Enhanced error logging without exposing details to clients
		logger.WithFields(logrus.Fields{
			"error": err.Error(),
			"query_param": uid,
		}).Error("Database query failed")
		return errors.New("database error occurred")
	}
	defer rows.Close()

	found := false
	for rows.Next() {
		err = rows.Scan(&p.Uid, &p.Name, &p.City, &p.PhoneNumber)
		if err != nil {
			logger.WithError(err).Error("Row scan error")
			return errors.New("error processing data")
		}
		found = true
	}
	
	// Check for errors after iteration
	if err = rows.Err(); err != nil {
		logger.WithError(err).Error("Error iterating over result rows")
		return errors.New("error processing data")
	}
	
	if !found {
		logger.WithField("user_id", uid).Info("No profile found for user ID")
		return errors.New("profile not found")
	}
	
	// Note: This function assumes DB connection uses a limited-privilege account
	// following the principle of least privilege at database level
	
	return nil
}

	return nil
}

func(p *Profile)SafeQueryGetData(uid string) error{

	/* this funciton use to get data Profile from database with prepare statement */

	const (
		getProfileSql = 
		`SELECT p.user_id, p.full_name, p.city, p.phone_number 
		FROM Profile as p,Users as u 
		where p.user_id = u.id 
		and u.id=?`) 
	
	stmt, err := DB.Prepare(getProfileSql) //prepare statement 
	if err != nil{
		return err
	}

	defer stmt.Close()
	err = stmt.QueryRow(uid).Scan(&p.Uid,&p.Name,&p.City,&p.PhoneNumber)
	if err != nil{
		return err
	}
	return nil
}
