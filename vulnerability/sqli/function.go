package sqli

import(
	"log"
	"fmt"
	"database/sql"

	"github.com/ShiftLeftSecurity/shiftleft-go-demo/util/database"
)

var DB *sql.DB
var err error

func init(){
	DB, err = database.Connect()
	if err != nil{
		log.Println(err.Error())
	}
}

type Profile struct{
	Uid int
	Name string
	City string
	PhoneNumber string
}

func NewProfile()*Profile{
	return &Profile{}
}

func(p *Profile)UnsafeQueryGetData(uid string)error{

	/* this function use to get data Profile from database with secure parameterized query */

	// Added: Input validation before database operations
	if !isValidUID(uid) {
		return fmt.Errorf("invalid user ID format")
	}

	// Using parameterized query with placeholders to prevent SQL injection
	getProfileSql := `SELECT p.user_id, p.full_name, p.city, p.phone_number 
					FROM Profile as p,Users as u 
					where p.user_id = u.id 
					and u.id=?`
	
	// Added: Context with timeout for query execution
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	// Added: Using prepared statements with context
	stmt, err := DB.PrepareContext(ctx, getProfileSql)
	if err != nil {
		// Added: Custom error type to hide implementation details
		return fmt.Errorf("database preparation error")
	}
	defer stmt.Close()

	// Added: Query execution with context and limiting results
	rows, err := stmt.QueryContext(ctx, uid)
	if err != nil {
		// Added: Generic error message to avoid exposing implementation details
		return fmt.Errorf("database query error")
	}
	defer rows.Close()

	// Added: Row count limiting to prevent potential DoS
	rowCount := 0
	maxRows := 100
	
	for rows.Next() {
		// Added: Row limit check to prevent DoS
		rowCount++
		if rowCount > maxRows {
			return fmt.Errorf("query returned too many rows")
		}
		
		err = rows.Scan(&p.Uid, &p.Name, &p.City, &p.PhoneNumber)
		if err != nil {
			// Added: Generic error logging that doesn't reveal query details
			log.Printf("Error scanning row: %d", rowCount)
			return fmt.Errorf("error processing results")
		}
	}
	
	// Added: Check for errors after iteration completes
	if err = rows.Err(); err != nil {
		return fmt.Errorf("error during result iteration")
	}
	
	return nil
}

// Added: Helper function to validate UID format
func isValidUID(uid string) bool {
	// Example validation - adjust according to your actual UID format
	// This assumes UIDs are alphanumeric and between 1-36 characters
	match, _ := regexp.MatchString("^[a-zA-Z0-9]{1,36}$", uid)
	return match
}

	return nil
}

func(p *Profile)SafeQueryGetData(uid string) error{

	/* this funciton use to get data Profile from database with prepare statement */

	const (
		getProfileSql = 
		`SELECT p.user_id, p.full_name, p.city, p.phone_number 
		FROM Profile as p,Users as u 
		where p.user_id = u.id 
		and u.id=?`) 
	
	stmt, err := DB.Prepare(getProfileSql) //prepare statement 
	if err != nil{
		return err
	}

	defer stmt.Close()
	err = stmt.QueryRow(uid).Scan(&p.Uid,&p.Name,&p.City,&p.PhoneNumber)
	if err != nil{
		return err
	}
	return nil
}
