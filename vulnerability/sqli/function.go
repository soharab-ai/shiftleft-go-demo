package sqli

import(
	"log"
	"fmt"
	"database/sql"

	"github.com/ShiftLeftSecurity/shiftleft-go-demo/util/database"
)

var DB *sql.DB
var err error

func init(){
	DB, err = database.Connect()
	if err != nil{
		log.Println(err.Error())
	}
}

type Profile struct{
	Uid int
	Name string
	City string
	PhoneNumber string
}

func NewProfile()*Profile{
	return &Profile{}
}

func(p *Profile)UnsafeQueryGetData(uid string)error{
// Custom error types to avoid exposing sensitive information
var (
    ErrInvalidUserID = errors.New("invalid user ID")
    ErrDatabaseQuery = errors.New("database query error")
    ErrNoDataFound   = errors.New("no data found")
)

// ProfileDataAccess handles all database interactions for Profile
type ProfileDataAccess struct {
    db     *sql.DB
    logger *zap.Logger
    stmt   *sql.Stmt
}

// NewProfileDataAccess creates a new data access layer for profiles
func NewProfileDataAccess(db *sql.DB) (*ProfileDataAccess, error) {
    // Initialize structured logger
    logger, err := zap.NewProduction()
    if err != nil {
        return nil, fmt.Errorf("failed to initialize logger: %w", err)
    }
    
    // Prepare statement for better performance and security
    stmt, err := db.Prepare(`SELECT p.user_id, p.full_name, p.city, p.phone_number 
                            FROM Profile as p, Users as u 
                            WHERE p.user_id = u.id 
                            AND u.id = ?`)
    if err != nil {
        logger.Error("failed to prepare statement", 
            zap.Error(err))
        return nil, fmt.Errorf("failed to prepare database statement: %w", err)
    }
    
    return &ProfileDataAccess{
        db:     db,
        logger: logger,
        stmt:   stmt,
    }, nil
}

// Close releases resources used by the data access layer
func (da *ProfileDataAccess) Close() error {
    if err := da.stmt.Close(); err != nil {
        da.logger.Error("failed to close prepared statement", 
            zap.Error(err))
        return err
    }
    return nil
}

func (p *Profile) UnsafeQueryGetData(uid string) error {
    // Create context with timeout for database operations
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()
    
    // Simplified input validation - only use strconv.Atoi as recommended
    userID, err := strconv.Atoi(uid)
    if err != nil {
        // Use structured logging to prevent log injection
        dataAccess.logger.Warn("invalid user ID format", 
            zap.String("uid", uid),
            zap.Error(err))
        return ErrInvalidUserID
    }
    
    // Use the prepared statement with context
    rows, err := dataAccess.stmt.QueryContext(ctx, userID)
    if err != nil {
        dataAccess.logger.Error("database query failed",
            zap.Int("user_id", userID),
            zap.Error(err))
        return ErrDatabaseQuery
    }
    defer rows.Close()
    
    found := false
    for rows.Next() {
        err = rows.Scan(&p.Uid, &p.Name, &p.City, &p.PhoneNumber)
        if err != nil {
            dataAccess.logger.Error("row scanning failed",
                zap.Int("user_id", userID),
                zap.Error(err))
            return ErrDatabaseQuery
        }
        found = true
    }
    
    // Check for any errors during row iteration
    if err = rows.Err(); err != nil {
        dataAccess.logger.Error("row iteration error",
            zap.Int("user_id", userID),
            zap.Error(err))
        return ErrDatabaseQuery
    }
    
    if !found {
        return ErrNoDataFound
    }
    
    return nil
}

					and u.id=?` // Using parameter placeholder
	
	// Create context with timeout for the query
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)  // Added context with timeout
	defer cancel()
	
	// Use prepared statements explicitly
	stmt, err := DB.PrepareContext(ctx, getProfileSql)  // Using explicit prepared statement
	if err != nil {
		log.Printf("Prepare error: %s", err.Error())
		return fmt.Errorf("error preparing database query")
	}
	defer stmt.Close()
	
	// Execute the query with context
	rows, err := stmt.QueryContext(ctx, uid)  // Using QueryContext with timeout
	if err != nil {
		// Don't expose raw DB errors to client
		log.Printf("Query error: %s", err.Error())
		return fmt.Errorf("error retrieving profile data")
	}
	defer rows.Close()
	
	found := false
	for rows.Next(){
		found = true
		err = rows.Scan(&p.Uid, &p.Name, &p.City, &p.PhoneNumber)
		if err != nil{
			log.Printf("Row scan error: %s", err.Error())
			return fmt.Errorf("error processing profile data")
		}
	}
	
	if !found {
		return fmt.Errorf("profile not found")
	}
	
	return nil
}

// Helper function to validate user ID format
func isValidUserId(uid string) bool {
	// Query whitelisting implementation - only accepting digits
	for _, c := range uid {
		if c < '0' || c > '9' {
			return false
		}
	}
	return len(uid) > 0 // Ensure the string is not empty
}

	return nil
}

func(p *Profile)SafeQueryGetData(uid string) error{

	/* this funciton use to get data Profile from database with prepare statement */

	const (
		getProfileSql = 
		`SELECT p.user_id, p.full_name, p.city, p.phone_number 
		FROM Profile as p,Users as u 
		where p.user_id = u.id 
		and u.id=?`) 
	
	stmt, err := DB.Prepare(getProfileSql) //prepare statement 
	if err != nil{
		return err
	}

	defer stmt.Close()
	err = stmt.QueryRow(uid).Scan(&p.Uid,&p.Name,&p.City,&p.PhoneNumber)
	if err != nil{
		return err
	}
	return nil
}
