package sqli

import(
	"log"
	"fmt"
	"database/sql"

	"github.com/ShiftLeftSecurity/shiftleft-go-demo/util/database"
)

var DB *sql.DB
var err error

func init(){
	DB, err = database.Connect()
	if err != nil{
		log.Println(err.Error())
	}
}

type Profile struct{
	Uid int
	Name string
	City string
	PhoneNumber string
}

func NewProfile()*Profile{
	return &Profile{}
}

func(p *Profile)UnsafeQueryGetData(uid string)error{
    // Enhanced input validation with length check and character set restriction
    if len(uid) > 10 {
        log.Printf("Attempt to use excessive length user ID: %s", uid)
        return errors.New("invalid user ID format: exceeds maximum length")
    }
    
    // Validate that uid is numeric and within acceptable range
    id, err := strconv.Atoi(uid)
    if err != nil || id <= 0 {
        log.Printf("Invalid user ID format attempted: %s", uid)
        return errors.New("invalid user ID format")
    }
    
    // Query whitelisting - verify this query is allowed
    getProfileSql := `SELECT p.user_id, p.full_name, p.city, p.phone_number 
                    FROM Profile as p, Users as u 
                    WHERE p.user_id = u.id 
                    AND u.id=?`
                    
    // Verify this is an approved query pattern
    if !isWhitelistedQuery(getProfileSql) {
        log.Printf("Unauthorized query pattern attempted")
        return errors.New("security policy violation")
    }

    // Create context with timeout to prevent long-running queries
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()

    // Begin transaction for better isolation and control
    tx, err := DB.BeginTx(ctx, nil)
    if err != nil {
        log.Printf("Transaction start error: %s", err.Error())
        return errors.New("database error occurred")
    }
    
    // Defer transaction rollback in case of error
    defer func() {
        if err != nil {
            tx.Rollback()
        }
    }()
    
    // Using prepared statement with parameter binding within transaction
    stmt, err := tx.PrepareContext(ctx, getProfileSql)
    if err != nil {
        log.Printf("Statement preparation error: %s", err.Error())
        return errors.New("database error occurred")
    }
    defer stmt.Close()
    
    // Execute query with context and parameters
    rows, err := stmt.QueryContext(ctx, uid)
    if err != nil {
        // Don't expose detailed error to clients
        log.Printf("Query error [User ID: %s]: %s", uid, err.Error())
        return errors.New("database error occurred")
    }
    defer rows.Close()
    
    found := false
    for rows.Next(){
        found = true
        err = rows.Scan(&p.Uid, &p.Name, &p.City, &p.PhoneNumber)
        if err != nil{
            log.Printf("Row scan error [User ID: %s]: %s", uid, err.Error())
            return errors.New("error processing results")
        }
    }
    
    if err = rows.Err(); err != nil {
        log.Printf("Rows iteration error [User ID: %s]: %s", uid, err.Error())
        return errors.New("database error occurred")
    }
    
    if !found {
        log.Printf("No data found for user ID: %s", uid)
        return errors.New("no data found")
    }
    
    // Commit the transaction if everything succeeded
    if err = tx.Commit(); err != nil {
        log.Printf("Transaction commit error [User ID: %s]: %s", uid, err.Error())
        return errors.New("database error occurred")
    }
    
    // Log successful query for audit purposes
    log.Printf("Profile data successfully retrieved for user ID: %s", uid)
    return nil
}

// Helper function to validate if a query matches approved patterns
func isWhitelistedQuery(query string) bool {
    // Whitelist of approved query patterns (simplified for example)
    approvedPatterns := []string{
        `SELECT p\.user_id, p\.full_name, p\.city, p\.phone_number\s+FROM Profile as p, Users as u\s+WHERE p\.user_id = u\.id\s+AND u\.id=\?`,
    }
    
    for _, pattern := range approvedPatterns {
        match, _ := regexp.MatchString(pattern, query)
        if match {
            return true
        }
    }
    return false
}

	return nil
}

func(p *Profile)SafeQueryGetData(uid string) error{

	/* this funciton use to get data Profile from database with prepare statement */

	const (
		getProfileSql = 
		`SELECT p.user_id, p.full_name, p.city, p.phone_number 
		FROM Profile as p,Users as u 
		where p.user_id = u.id 
		and u.id=?`) 
	
	stmt, err := DB.Prepare(getProfileSql) //prepare statement 
	if err != nil{
		return err
	}

	defer stmt.Close()
	err = stmt.QueryRow(uid).Scan(&p.Uid,&p.Name,&p.City,&p.PhoneNumber)
	if err != nil{
		return err
	}
	return nil
}
