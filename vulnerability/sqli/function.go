package sqli

import(
	"log"
	"fmt"
	"database/sql"

	"github.com/ShiftLeftSecurity/shiftleft-go-demo/util/database"
)

var DB *sql.DB
var err error

func init(){
	DB, err = database.Connect()
	if err != nil{
		log.Println(err.Error())
	}
}

type Profile struct{
	Uid int
	Name string
	City string
	PhoneNumber string
}

func NewProfile()*Profile{
	return &Profile{}
}

func(p *Profile)UnsafeQueryGetData(uid string)error{
// Structure for unified error responses
type ErrorResponse struct {
    Code    string `json:"code"`
    Message string `json:"message"`
}

// Global variables
var (
    validate *validator.Validate
    logger   *logrus.Logger
    redisClient *redis.Client
    DB       *sqlx.DB
    // Regular expression for user ID validation - only positive integers
    uidRegex = regexp.MustCompile(`^[1-9]\d*$`)
)

// Initialize security components
func init() {
    // Initialize structured logger
    logger = logrus.New()
    logger.SetFormatter(&logrus.JSONFormatternull)
    
    // Initialize validator
    validate = validator.New()
    
    // Initialize Redis client for caching
    redisClient = redis.NewClient(&redis.Options{
        Addr:     "localhost:6379",
        Password: "", // Set password if needed
        DB:       0,
    })
}

// DataAccessLayer implements a security wrapper for database operations
type DataAccessLayer struct {
    db *sqlx.DB
}

// NewDataAccessLayer creates a new data access layer
func NewDataAccessLayer(db *sqlx.DB) *DataAccessLayer {
    return &DataAccessLayer{db: db}
}

// GetUserProfile retrieves a user profile with security measures
func (dal *DataAccessLayer) GetUserProfile(ctx context.Context, uid int) (*Profile, error) {
    // Use query builder for safer query construction
    query, args, err := squirrel.Select("p.user_id", "p.full_name", "p.city", "p.phone_number").
        From("Profile as p").
        Join("Users as u ON p.user_id = u.id").
        Where(squirrel.Eq{"u.id": uid}).
        PlaceholderFormat(squirrel.Question).
        ToSql()
        
    if err != nil {
        logger.WithFields(logrus.Fields{
            "error": err.Error(),
            "requestID": ctx.Value("requestID"),
        }).Error("Failed to build SQL query")
        return nil, &ErrorResponse{Code: "DB_QUERY_BUILD_ERROR", Message: "Error preparing database query"}
    }
    
    // Add query to the context for logging
    logger.WithFields(logrus.Fields{
        "uid": uid,
        "requestID": ctx.Value("requestID"),
    }).Debug("Executing database query")
    
    // Try to get from cache first
    cacheKey := fmt.Sprintf("user_profile:%d", uid)
    cachedProfile, err := redisClient.Get(ctx, cacheKey).Result()
    if err == nil && cachedProfile != "" {
        // Deserialize and return cached profile
        // (simplified here - actual implementation would deserialize JSON)
        logger.WithField("uid", uid).Debug("Profile retrieved from cache")
        // For demonstration, still querying DB but in practice would return cached data
    }
    
    var profile Profile
    // Use context with timeout for the query
    rows, err := dal.db.QueryxContext(ctx, query, args...)
    if err != nil {
        logger.WithFields(logrus.Fields{
            "error": err.Error(),
            "uid": uid,
            "requestID": ctx.Value("requestID"),
        }).Error("Database query failed")
        return nil, &ErrorResponse{Code: "DB_QUERY_ERROR", Message: "Error retrieving user data"}
    }
    defer rows.Close()
    
    found := false
    for rows.Next() {
        found = true
        err = rows.StructScan(&profile)
        if err != nil {
            logger.WithFields(logrus.Fields{
                "error": err.Error(),
                "uid": uid,
                "requestID": ctx.Value("requestID"),
            }).Error("Failed to scan row data")
            return nil, &ErrorResponse{Code: "DATA_MAPPING_ERROR", Message: "Error processing user data"}
        }
    }
    
    if !found {
        return nil, &ErrorResponse{Code: "NOT_FOUND", Message: "No matching user profile found"}
    }
    
    // Cache the result
    // (simplified - actual implementation would serialize to JSON)
    err = redisClient.Set(ctx, cacheKey, "profile_data", 15*time.Minute).Err()
    if err != nil {
        logger.WithFields(logrus.Fields{
            "error": err.Error(),
            "uid": uid,
        }).Warning("Failed to cache profile")
        // Continue despite cache error
    }
    
    return &profile, nil
}

func(p *Profile) UnsafeQueryGetData(uid string) error {
    // Create request context with timeout
    ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
    defer cancel()
    
    // Add request ID to context
    requestID := fmt.Sprintf("req-%d", time.Now().UnixNano())
    ctx = context.WithValue(ctx, "requestID", requestID)
    
    // Enhanced input validation using regex and validator
    if !uidRegex.MatchString(uid) {
        logger.WithFields(logrus.Fields{
            "uid": uid,
            "requestID": requestID,
            "validation": "regex_failed",
        }).Warn("Invalid user ID format")
        return &ErrorResponse{Code: "INVALID_INPUT", Message: "Invalid user ID format"}
    }
    
    // Convert to int with additional validation
    uidInt, err := strconv.Atoi(uid)
    if err != nil || uidInt <= 0 {
        logger.WithFields(logrus.Fields{
            "uid": uid,
            "requestID": requestID,
        }).Warn("User ID must be a positive integer")
        return &ErrorResponse{Code: "INVALID_INPUT", Message: "User ID must be a positive integer"}
    }
    
    // Use the data access layer for secure database access
    dal := NewDataAccessLayer(DB)
    profile, err := dal.GetUserProfile(ctx, uidInt)
    if err != nil {
        return err // Error is already properly formatted by the data access layer
    }
    
    // Copy profile data to the current profile object
    p.Uid = profile.Uid
    p.Name = profile.Name
    p.City = profile.City
    p.PhoneNumber = profile.PhoneNumber
    
    return nil
}

func (l *Logger) LogQuery(queryName, queryTemplate string) {
    // Log query pattern (not parameters) for security monitoring
    l.logFile.Printf("Executing query pattern: %s, template: %s", queryName, queryTemplate)
}

func init() {
    // Initialize validator
    validate = validator.New()
    // Initialize logger
    logger = NewLogger()
    // In a real environment, this would use proper configuration
    // DB, err = sql.Open("mysql", "read_only_user:password@/database")
}

// isValidUID validates if the user ID follows the expected pattern
func isValidUID(uid string) bool {
    // Only allow alphanumeric user IDs
    match, _ := regexp.MatchString("^[a-zA-Z0-9]+$", uid)
    return match
}

// ExecuteWhitelistedQuery runs a query from the whitelist
func ExecuteWhitelistedQuery(queryName string, params ...interfacenull) (*sql.Rows, error) {
    queryTemplate, exists := allowedQueries[queryName]
    if !exists {
        return nil, fmt.Errorf("query template not in whitelist: %s", queryName)
    }
    
    // Log the query being executed (without parameters)
    logger.LogQuery(queryName, queryTemplate)
    
    // Execute query with parameters
    return DB.Query(queryTemplate, params...)
}

func(p *Profile)UnsafeQueryGetData(uid string)error{
    // This function now uses multiple security layers to prevent SQL injection
    
    // 1. Validate input format first
    if !isValidUID(uid) {
        return fmt.Errorf("invalid user ID format")
    }
    
    // 2. Use whitelisted query with parameterization
    rows, err := ExecuteWhitelistedQuery("profile_get", uid)
    if err != nil {
        // Secure logging - avoid including raw user input in error logs
        log.Printf("Database query error: %s", err.Error())
        return err
    }
    defer rows.Close()
    
    // 3. Process results with proper error handling
    foundData := false
    for rows.Next(){
        foundData = true
        err = rows.Scan(&p.Uid, &p.Name, &p.City, &p.PhoneNumber)
        if err != nil{
            log.Printf("Row scan error: %s", err.Error())
            return err
        }
    }
    
    // 4. Check for additional errors from iterating over rows
    if err = rows.Err(); err != nil {
        log.Printf("Row iteration error: %s", err.Error())
        return err
    }
    
    // 5. Validate we got expected data
    if !foundData {
        return fmt.Errorf("no data found for user ID")
    }
    
    return nil
}

// StoredProcQueryGetData uses stored procedures for additional security
func(p *Profile)StoredProcQueryGetData(uid string)error{
    // In a real implementation, this would call a stored procedure
    _, err := DB.Exec("CALL get_profile_data(?)", uid)
    if err != nil {
        log.Printf("Stored procedure error: %s", err.Error())
        return err
    }
    // Process results from stored procedure
    // (This is a simplified example)
    return nil
}

// OrmQueryGetData demonstrates using an ORM layer
func(p *Profile)OrmQueryGetData(uid string)error{
    // This is a simplified example of how an ORM would be used
    // In real code, proper ORM setup and error handling would be implemented
    db := gorm.DB
    type Result struct {
        UserID      string
        FullName    string
        City        string
        PhoneNumber string
    }
    
    var result Result
    if err := db.Raw("SELECT p.user_id, p.full_name, p.city, p.phone_number FROM Profile as p, Users as u WHERE p.user_id = u.id AND u.id = ?", uid).Scan(&result).Error; err != nil {
        return err
    }
    
    p.Uid = result.UserID
    p.Name = result.FullName
    p.City = result.City
    p.PhoneNumber = result.PhoneNumber
    
    return nil
}

func(p *Profile)SafeQueryGetData(uid string) error{

	/* this funciton use to get data Profile from database with prepare statement */

	const (
		getProfileSql = 
		`SELECT p.user_id, p.full_name, p.city, p.phone_number 
		FROM Profile as p,Users as u 
		where p.user_id = u.id 
		and u.id=?`) 
	
	stmt, err := DB.Prepare(getProfileSql) //prepare statement 
	if err != nil{
		return err
	}

	defer stmt.Close()
	err = stmt.QueryRow(uid).Scan(&p.Uid,&p.Name,&p.City,&p.PhoneNumber)
	if err != nil{
		return err
	}
	return nil
}
