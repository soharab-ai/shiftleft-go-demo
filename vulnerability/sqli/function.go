package sqli

import(
	"log"
	"fmt"
	"database/sql"

	"github.com/ShiftLeftSecurity/shiftleft-go-demo/util/database"
)

var DB *sql.DB
var err error

func init(){
	DB, err = database.Connect()
	if err != nil{
		log.Println(err.Error())
	}
}

type Profile struct{
	Uid int
	Name string
	City string
	PhoneNumber string
}

func NewProfile()*Profile{
	return &Profile{}
}

func(p *Profile)UnsafeQueryGetData(uid string)error{
	// Enhanced input validation to prevent SQL injection and integer overflow attacks
	validID, err := validateUserID(uid)
	if err != nil {
		// Improved error handling to prevent information leakage
		log.Printf("Input validation error: %s", err.Error()) // For internal logging
		return errors.New("invalid user input") // Generic message for external users
	}

	// Using parameterized query to prevent SQL injection
	getProfileSql := `SELECT p.user_id, p.full_name, p.city, p.phone_number 
					FROM Profile as p,Users as u 
					where p.user_id = u.id 
					and u.id=?`
	
	// Implement transaction management for better data integrity
	tx, err := DB.Begin()
	if err != nil {
		log.Printf("Transaction start error: %s", err.Error())
		return errors.New("database error occurred")
	}
	defer tx.Rollback()
					
	// Using prepared statement within transaction for added security
	stmt, err := tx.Prepare(getProfileSql)
	if err != nil {
		log.Printf("Prepare statement error: %s", err.Error())
		return errors.New("database error occurred")
	}
	defer stmt.Close()
	
	// Implement context-based query with timeout to prevent DoS attacks
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()
	
	rows, err := stmt.QueryContext(ctx, validID)
	if err != nil {
		log.Printf("Database query error: %s", err.Error())
		return errors.New("database error occurred")
	}
	defer rows.Close()
	
	found := false
	for rows.Next(){
		err = rows.Scan(&p.Uid,&p.Name,&p.City,&p.PhoneNumber)
		if err != nil{
			log.Printf("Row scan error: %s", err.Error())
			return errors.New("data processing error")
		}
		found = true
	}
	
	if !found {
		return errors.New("no profile found")
	}
	
	// Commit transaction when successful
	if err = tx.Commit(); err != nil {
		log.Printf("Transaction commit error: %s", err.Error())
		return errors.New("database error occurred")
	}
	
	return nil
}

// Enhanced validation function to check if input is valid and prevent integer overflow attacks
func validateUserID(uid string) (int, error) {
	// Check length to prevent integer overflow attacks
	if len(uid) > 10 {
		return 0, fmt.Errorf("user ID too long")
	}
	id, err := strconv.ParseInt(uid, 10, 32)
	if err != nil || id <= 0 {
		return 0, fmt.Errorf("invalid user ID")
	}
	return int(id), nil
}

// InitDB initializes database connection with proper connection pooling
func InitDB(dataSourceName string) (*sql.DB, error) {
	db, err := sql.Open("mysql", dataSourceName)
	if err != nil {
		return nil, err
	}
	
	// Implement database connection pooling configuration
	db.SetMaxOpenConns(25)
	db.SetMaxIdleConns(5) 
	db.SetConnMaxLifetime(5 * time.Minute)
	
	return db, nil
}

	return nil
}

func(p *Profile)SafeQueryGetData(uid string) error{

	/* this funciton use to get data Profile from database with prepare statement */

	const (
		getProfileSql = 
		`SELECT p.user_id, p.full_name, p.city, p.phone_number 
		FROM Profile as p,Users as u 
		where p.user_id = u.id 
		and u.id=?`) 
	
	stmt, err := DB.Prepare(getProfileSql) //prepare statement 
	if err != nil{
		return err
	}

	defer stmt.Close()
	err = stmt.QueryRow(uid).Scan(&p.Uid,&p.Name,&p.City,&p.PhoneNumber)
	if err != nil{
		return err
	}
	return nil
}
