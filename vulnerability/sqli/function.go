package sqli

import(
	"log"
	"fmt"
	"database/sql"

	"github.com/ShiftLeftSecurity/shiftleft-go-demo/util/database"
)

var DB *sql.DB
var err error

func init(){
	DB, err = database.Connect()
	if err != nil{
		log.Println(err.Error())
	}
}

type Profile struct{
	Uid int
	Name string
	City string
	PhoneNumber string
}

func NewProfile()*Profile{
	return &Profile{}
}

func(p *Profile)UnsafeQueryGetData(uid string)error{
	/* this function uses parameterized query and additional security measures to prevent SQL injection */
	
	// Enhanced input validation to ensure uid is numeric and within valid range
	if !isValidUID(uid) {
		return fmt.Errorf("invalid user ID format")
	}
	
	// Using prepared statement instead of direct query
	getProfileSql := `SELECT p.user_id, p.full_name, p.city, p.phone_number 
					FROM Profile as p, Users as u 
					WHERE p.user_id = u.id 
					AND u.id = ?` // Using placeholder instead of direct concatenation
	
	// Implement query timeout with context
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()
	
	// Prepare statement for better security and performance
	stmt, err := DB.PrepareContext(ctx, getProfileSql)
	if err != nil {
		return sanitizeDatabaseError(err)
	}
	defer stmt.Close()
	
	// Execute query with prepared statement
	rows, err := stmt.QueryContext(ctx, uid)
	if err != nil {
		return sanitizeDatabaseError(err)
	}
	defer rows.Close()
	
	for rows.Next(){
		err = rows.Scan(&p.Uid, &p.Name, &p.City, &p.PhoneNumber)
		if err != nil {
			log.Printf("Row scan error: %v", sanitizeLogMessage(err.Error()))
			return sanitizeDatabaseError(err)
		}
	}
	
	// Check for errors after iteration
	if err = rows.Err(); err != nil {
		return sanitizeDatabaseError(err)
	}
	
	return nil
}

// Helper function to validate that the user ID contains only numeric values and is within valid range
func isValidUID(uid string) bool {
	id, err := strconv.ParseInt(uid, 10, 64)
	if err != nil {
		return false
	}
	// Add additional validation checking range
	const MAX_ALLOWED_ID = 1000000000 // Example maximum ID value
	return id > 0 && id < MAX_ALLOWED_ID
}

// Sanitize database errors to prevent information disclosure
func sanitizeDatabaseError(err error) error {
	if err == nil {
		return nil
	}
	// Return generic error message to avoid leaking database details
	return fmt.Errorf("database operation failed: %s", err.Error())
}

// Sanitize log messages to prevent log injection
func sanitizeLogMessage(message string) string {
	// Simple sanitization to prevent log forging - in production use a proper sanitization library
	// Remove potential control characters, newlines that could be used for log injection
	sanitized := ""
	for _, r := range message {
		if r >= 32 && r != 127 {
			sanitized += string(r)
		}
	}
	return sanitized
}

	// Prepare statement for better security and performance
	stmt, err := DB.PrepareContext(ctx, getProfileSql)
	if err != nil {
		log.Printf("Statement preparation error: %s", err.Error())
		return fmt.Errorf("failed to prepare database query")
	}
	defer stmt.Close()
	
	// Execute query with context and parameters
	rows, err := stmt.QueryContext(ctx, userID)
	if err != nil {
		log.Printf("Query error: %s", err.Error())
		return fmt.Errorf("failed to retrieve profile data")
	}
	defer rows.Close()
	
	found := false
	for rows.Next(){
		err = rows.Scan(&p.Uid,&p.Name,&p.City,&p.PhoneNumber)
		if err != nil{
			log.Printf("Row scan error: %s", err.Error())
			return fmt.Errorf("error processing profile data")
		}
		found = true
	}
	
	if !found {
		return fmt.Errorf("no profile found")
	}
	
	return nil
}

	return nil
}

func(p *Profile)SafeQueryGetData(uid string) error{

	/* this funciton use to get data Profile from database with prepare statement */

	const (
		getProfileSql = 
		`SELECT p.user_id, p.full_name, p.city, p.phone_number 
		FROM Profile as p,Users as u 
		where p.user_id = u.id 
		and u.id=?`) 
	
	stmt, err := DB.Prepare(getProfileSql) //prepare statement 
	if err != nil{
		return err
	}

	defer stmt.Close()
	err = stmt.QueryRow(uid).Scan(&p.Uid,&p.Name,&p.City,&p.PhoneNumber)
	if err != nil{
		return err
	}
	return nil
}
