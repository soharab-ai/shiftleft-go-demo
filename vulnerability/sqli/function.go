package sqli

import(
	"log"
	"fmt"
	"database/sql"

	"github.com/ShiftLeftSecurity/shiftleft-go-demo/util/database"
)

var DB *sql.DB
var err error

func init(){
	DB, err = database.Connect()
	if err != nil{
		log.Println(err.Error())
	}
}

type Profile struct{
	Uid int
	Name string
	City string
	PhoneNumber string
}

func NewProfile()*Profile{
	return &Profile{}
}

func(p *Profile)UnsafeQueryGetData(uid string)error{
	/* this function gets data Profile from database with secure query */
	
	// Added input validation to ensure uid is valid before proceeding
	if uid == "" {
		return errors.New("user ID cannot be empty")
	}
	
	// Added validation for proper UID format (assuming numeric ID)
	if !isValidUID(uid) {
		return fmt.Errorf("invalid user ID format: %s", uid)
	}

	getProfileSql := `SELECT p.user_id, p.full_name, p.city, p.phone_number 
					FROM Profile as p,Users as u 
					where p.user_id = u.id 
					and u.id=?`
	
	// Added context with timeout to prevent hanging queries
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()
	
	// Using prepared statement for better security and performance
	stmt, err := DB.PrepareContext(ctx, getProfileSql)
	if err != nil {
		return fmt.Errorf("prepare statement error: %w", err)
	}
	defer stmt.Close()
	
	// Execute the prepared statement with the parameter
	rows, err := stmt.QueryContext(ctx, uid)
	if err != nil {
		return fmt.Errorf("database query error: %w", err)
	}
	defer rows.Close()
	
	found := false
	for rows.Next() {
		found = true
		err = rows.Scan(&p.Uid, &p.Name, &p.City, &p.PhoneNumber)
		if err != nil {
			return fmt.Errorf("row scan error: %w", err)
		}
	}
	
	// Check for errors from iterating over rows
	if err = rows.Err(); err != nil {
		return fmt.Errorf("rows iteration error: %w", err)
	}
	
	// Added check to see if any results were found
	if !found {
		return fmt.Errorf("no profile found for user ID: %s", uid)
	}
	
	return nil
}

// Added helper function for UID validation
func isValidUID(uid string) bool {
	// Implement validation logic (checking if uid is numeric)
	match, _ := regexp.MatchString("^[0-9]+$", uid)
	return match
}

    defer tx.Rollback() // Will rollback if not committed
    
    // Use parameterized query with placeholders
    getProfileSql := `SELECT p.user_id, p.full_name, p.city, p.phone_number 
                    FROM Profile as p, Users as u 
                    WHERE p.user_id = u.id 
                    AND u.id = ?`
    
    // Create and use prepared statement
    stmt, err := tx.PrepareContext(ctx, getProfileSql)
    if err != nil {
        return fmt.Errorf("failed to prepare statement: %w", err)
    }
    defer stmt.Close()
    
    // Execute the prepared statement with parameters
    rows, err := stmt.QueryContext(ctx, uid)
    if err != nil {
        return fmt.Errorf("query execution failed: %w", err)
    }
    defer rows.Close()
    
    found := false
    for rows.Next() {
        found = true
        err = rows.Scan(&p.Uid, &p.Name, &p.City, &p.PhoneNumber)
        if err != nil {
            log.Printf("Row scan error: %s", err.Error())
            return fmt.Errorf("data scan error: %w", err)
        }
    }
    
    if err = rows.Err(); err != nil {
        return fmt.Errorf("error iterating rows: %w", err)
    }
    
    if !found {
        return fmt.Errorf("no data found")
    }
    
    // Commit the transaction
    if err = tx.Commit(); err != nil {
        return fmt.Errorf("failed to commit transaction: %w", err)
    }
    
    return nil
}

	return nil
}

func(p *Profile)SafeQueryGetData(uid string) error{

	/* this funciton use to get data Profile from database with prepare statement */

	const (
		getProfileSql = 
		`SELECT p.user_id, p.full_name, p.city, p.phone_number 
		FROM Profile as p,Users as u 
		where p.user_id = u.id 
		and u.id=?`) 
	
	stmt, err := DB.Prepare(getProfileSql) //prepare statement 
	if err != nil{
		return err
	}

	defer stmt.Close()
	err = stmt.QueryRow(uid).Scan(&p.Uid,&p.Name,&p.City,&p.PhoneNumber)
	if err != nil{
		return err
	}
	return nil
}
