package sqli

import(
	"log"
	"fmt"
	"database/sql"

	"github.com/ShiftLeftSecurity/shiftleft-go-demo/util/database"
)

var DB *sql.DB
var err error

func init(){
	DB, err = database.Connect()
	if err != nil{
		log.Println(err.Error())
	}
}

type Profile struct{
	Uid int
	Name string
	City string
	PhoneNumber string
}

func NewProfile()*Profile{
	return &Profile{}
}

// Global prepared statement
var getProfileStmt *sql.Stmt

// Initialize prepared statements
func InitPreparedStatements(db *sql.DB) error {
	// Added prepared statement initialization for better security and performance
	var err error
	getProfileStmt, err = db.Prepare(`SELECT p.user_id, p.full_name, p.city, p.phone_number 
					FROM Profile as p, Users as u 
					where p.user_id = u.id 
					and u.id=?`)
	return err
}

// Enhanced version with context, prepared statements and transactions
func(p *Profile) UnsafeQueryGetData(uid string) error {
	// Create a context with timeout for better resource control
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()
	
	return p.UnsafeQueryGetDataWithContext(ctx, uid)
}

// New context-aware implementation as suggested in mitigation notes
func(p *Profile) UnsafeQueryGetDataWithContext(ctx context.Context, uid string) error {
	// Enhanced input validation with multiple checks
	if err := isValidID(uid); err != nil {
		return fmt.Errorf("invalid user ID: %w", err)
	}

	// Start a transaction for better data integrity
	tx, err := DB.BeginTx(ctx, nil)
	if err != nil {
		return fmt.Errorf("failed to start transaction: %w", err)
	}
	defer tx.Rollback() // Will be ignored if transaction is committed

	// Using the prepared statement with transaction and context
	rows, err := tx.StmtContext(ctx, getProfileStmt).QueryContext(ctx, uid)
	if err != nil {
		return fmt.Errorf("query execution error: %w", err)
	}
	defer rows.Close()
	
	found := false
	for rows.Next() {
		err = rows.Scan(&p.Uid, &p.Name, &p.City, &p.PhoneNumber)
		if err != nil {
			log.Printf("Row scan error: %s", err.Error())
			return fmt.Errorf("data scan error: %w", err)
		}
		found = true
	}

	if err = rows.Err(); err != nil {
		return fmt.Errorf("error iterating rows: %w", err)
	}

	if !found {
		return fmt.Errorf("no profile found for ID: %s", uid)
	}
	
	// Commit the transaction
	if err := tx.Commit(); err != nil {
		return fmt.Errorf("failed to commit transaction: %w", err)
	}
	
	return nil
}

// Enhanced validation function with more robust checks
func isValidID(id string) error {
	// Check if empty
	if id == "" {
		return fmt.Errorf("ID cannot be empty")
	}
	
	// Check if it's a reasonable length (prevent extremely long inputs)
	if len(id) > 20 {
		return fmt.Errorf("ID exceeds maximum allowed length")
	}
	
	// Check if numeric
	match, err := regexp.MatchString(`^[0-9]+$`, id)
	if err != nil {
		return fmt.Errorf("validation error: %w", err)
	}
	if !match {
		return fmt.Errorf("ID must contain only numeric characters")
	}
	
	return nil
}


func(p *Profile)SafeQueryGetData(uid string) error{

	/* this funciton use to get data Profile from database with prepare statement */

	const (
		getProfileSql = 
		`SELECT p.user_id, p.full_name, p.city, p.phone_number 
		FROM Profile as p,Users as u 
		where p.user_id = u.id 
		and u.id=?`) 
	
	stmt, err := DB.Prepare(getProfileSql) //prepare statement 
	if err != nil{
		return err
	}

	defer stmt.Close()
	err = stmt.QueryRow(uid).Scan(&p.Uid,&p.Name,&p.City,&p.PhoneNumber)
	if err != nil{
		return err
	}
	return nil
}
