package sqli

import(
	"log"
	"fmt"
	"database/sql"

	"github.com/ShiftLeftSecurity/shiftleft-go-demo/util/database"
)

var DB *sql.DB
var err error

func init(){
	DB, err = database.Connect()
	if err != nil{
		log.Println(err.Error())
	}
}

type Profile struct{
	Uid int
	Name string
	City string
	PhoneNumber string
}

func NewProfile()*Profile{
	return &Profile{}
}

func(p *Profile)UnsafeQueryGetData(uid string)error{
// Package-level variables for prepared statements
var (
    profileStmt *sql.Stmt
    stmtOnce    sync.Once
    stmtErr     error
)

// InitStatements initializes prepared statements for reuse
func InitStatements(db *sql.DB) error {
    var err error
    stmtOnce.Do(func() {
        // Store prepared statement for repeated use
        profileStmt, err = db.Prepare(`SELECT p.user_id, p.full_name, p.city, p.phone_number 
                FROM Profile as p, Users as u 
                WHERE p.user_id = u.id 
                AND u.id = ?`)
        stmtErr = err
    })
    return stmtErr
}

// UnsafeQueryGetData now accepts context and uses prepared statements
func(p *Profile) UnsafeQueryGetData(ctx context.Context, uid string) error {
    // Enhanced validation: check if numeric and positive
    id, err := strconv.Atoi(uid)
    if err != nil || id <= 0 {
        // Added additional validation beyond just numeric check
        return errors.New("invalid user ID format or value")
    }
    
    // Verify the prepared statement has been initialized
    if profileStmt == nil {
        return errors.New("database not properly initialized")
    }

    // Using prepared statement with context support
    rows, err := profileStmt.QueryContext(ctx, uid)
    if err != nil {
        log.Printf("Database query error: %s", err.Error())
        return errors.New("database error occurred")
    }
    defer rows.Close()
    
    found := false
    for rows.Next() {
        found = true
        
        // Implementing row scanning safeguards with nullable fields
        var nullableCity, nullablePhone sql.NullString
        err = rows.Scan(&p.Uid, &p.Name, &nullableCity, &nullablePhone)
        if err != nil {
            log.Printf("Row scan error: %s", err.Error())
            return errors.New("error processing data")
        }
        
        // Handle NULL values from database properly
        if nullableCity.Valid {
            p.City = nullableCity.String
        } else {
            p.City = "" // Set default value for NULL
        }
        
        if nullablePhone.Valid {
            p.PhoneNumber = nullablePhone.String
        } else {
            p.PhoneNumber = "" // Set default value for NULL
        }
    }
    
    // Check for errors from iteration
    if err = rows.Err(); err != nil {
        log.Printf("Row iteration error: %s", err.Error())
        return errors.New("error processing result set")
    }
    
    if !found {
        return errors.New("no data found")
    }
    
    return nil
}

        sqlDB, err := db.DB()
        if err != nil {
            log.Fatalf("Failed to get database connection: %v", err)
        }
        
        // Set pool configuration to protect against DoS
        sqlDB.SetMaxIdleConns(10)
        sqlDB.SetMaxOpenConns(100)
        sqlDB.SetConnMaxLifetime(time.Hour)
        
        // Initialize repository with whitelisted queries
        repo = &ProfileRepository{
            db: db,
            queryWhitelist: map[string]string{
                "getProfileData": "SELECT p.user_id, p.full_name, p.city, p.phone_number FROM Profile as p JOIN Users as u ON p.user_id = u.id WHERE u.id = ?",
            },
        }
    })
    return repo
}

// User and Profile models for ORM
type User struct {
    ID uint `gorm:"primaryKey"`
}

type ProfileModel struct {
    UserID uint `gorm:"column:user_id;primaryKey"`
    FullName string `gorm:"column:full_name"`
    City string `gorm:"column:city"`
    PhoneNumber string `gorm:"column:phone_number"`
}

// GetProfileData retrieves profile data using the repository pattern and ORM
func (repo *ProfileRepository) GetProfileData(uid string, profile *Profile) error {
    // Input validation: Check if uid is a valid integer
    userID, err := strconv.Atoi(uid)
    if err != nil {
        return errors.New("invalid user ID format")
    }
    
    // Create a context with timeout for database operations
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()

    // Using ORM approach - first implementation suggested in mitigation notes
    var profileModel ProfileModel
    result := repo.db.WithContext(ctx).Table("Profile").
        Select("Profile.user_id, Profile.full_name, Profile.city, Profile.phone_number").
        Joins("JOIN Users ON Profile.user_id = Users.id").
        Where("Users.id = ?", userID).
        First(&profileModel)
        
    if result.Error != nil {
        // Log the actual error but return a generic error to the user
        log.Printf("Database error: %v", result.Error)
        return errors.New("database error")
    }
    
    // Map the ORM model to the original Profile struct
    profile.Uid = fmt.Sprintf("%d", profileModel.UserID)
    profile.Name = profileModel.FullName
    profile.City = profileModel.City
    profile.PhoneNumber = profileModel.PhoneNumber
    
    return nil
}

// UnsafeQueryGetData now uses the repository pattern and ORM for secure database access
func (p *Profile) UnsafeQueryGetData(uid string) error {
    // Using repository pattern to abstract database operations
    repo := GetProfileRepository()
    return repo.GetProfileData(uid, p)
}

func(p *Profile)SafeQueryGetData(uid string) error{

	/* this funciton use to get data Profile from database with prepare statement */

	const (
		getProfileSql = 
		`SELECT p.user_id, p.full_name, p.city, p.phone_number 
		FROM Profile as p,Users as u 
		where p.user_id = u.id 
		and u.id=?`) 
	
	stmt, err := DB.Prepare(getProfileSql) //prepare statement 
	if err != nil{
		return err
	}

	defer stmt.Close()
	err = stmt.QueryRow(uid).Scan(&p.Uid,&p.Name,&p.City,&p.PhoneNumber)
	if err != nil{
		return err
	}
	return nil
}
