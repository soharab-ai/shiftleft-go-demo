package sqli

import(
	"log"
	"fmt"
	"database/sql"

	"github.com/ShiftLeftSecurity/shiftleft-go-demo/util/database"
)

var DB *sql.DB
var err error

func init(){
	DB, err = database.Connect()
	if err != nil{
		log.Println(err.Error())
	}
}

type Profile struct{
	Uid int
	Name string
	City string
	PhoneNumber string
}

func NewProfile()*Profile{
	return &Profile{}
}

func(p *Profile)UnsafeQueryGetData(uid string)error{
	// Fixed: Add explicit length check for input parameter
	if len(uid) > 10 {
		return errors.New("invalid user ID length")
	}

	// Fixed: Validate that uid is a valid integer to prevent SQL injection
	uidInt, err := strconv.Atoi(uid)
	if err != nil {
		return errors.New("invalid user ID format")
	}

	// Fixed: Use prepared statements instead of direct parameterization
	getProfileSql := `SELECT p.user_id, p.full_name, p.city, p.phone_number 
					FROM Profile as p, Users as u 
					where p.user_id = u.id 
					and u.id=?`
	
	// Fixed: Add context support with timeout for database operations
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()
	
	// Fixed: Implement rate limiting to prevent brute force attempts
	limiter := rate.NewLimiter(rate.Every(100*time.Millisecond), 10) // 10 requests per second
	if !limiter.Allow() {
		return errors.New("too many requests")
	}
	
	// Fixed: Use prepared statements for better security
	stmt, err := DB.Prepare(getProfileSql)
	if err != nil {
		log.Printf("Statement preparation error: %s", err.Error())
		return errors.New("database error")
	}
	defer stmt.Close()
	
	// Fixed: Add query execution time monitoring
	startTime := time.Now()
	rows, err := stmt.QueryContext(ctx, uidInt)
	queryTime := time.Since(startTime)
	if queryTime > 500*time.Millisecond {
		log.Printf("Warning: Slow query detected (%s) for uid %s", queryTime, uid)
	}
	
	if err != nil{
		// Fixed: Don't return raw SQL error to client
		log.Printf("Query error: %s", err.Error())
		return errors.New("database query failed")
	}
	defer rows.Close()
	
	found := false
	for rows.Next(){
		found = true
		err = rows.Scan(&p.Uid,&p.Name,&p.City,&p.PhoneNumber)
		if err != nil{
			log.Printf("Row scan error: %s", err.Error())
			return errors.New("error processing data")
		}
	}
	
	if !found {
		return errors.New("no user profile found")
	}
	
	return nil
}


    // Added: Use context with timeout to prevent long-running queries
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()
    
    // Added: Query whitelisting check
    if !isWhitelistedQuery("getProfile") {
        return errors.New("unauthorized query operation")
    }
    
    // Added: Use prepared statement with context
    rows, err := getProfileStmt.QueryContext(ctx, uid)
    if err != nil{
        return err
    }
    defer rows.Close()
    
    for rows.Next(){
        err = rows.Scan(&p.Uid, &p.Name, &p.City, &p.PhoneNumber)
        if err != nil{
            // Added: Safe error logging, avoiding potential log injection
            log.Printf("Row scan error: %s", sanitizeLogMessage(err.Error()))
            return err
        }
    }
    
    // Check for errors encountered during iteration
    if err = rows.Err(); err != nil {
        return err
    }
    
    return nil
}

// Added: Enhanced validation using regex
func validateUID(uid string) bool {
    // Use regex for validation - only digits allowed
    match, _ := regexp.MatchString(`^[0-9]+$`, uid)
    return match && len(uid) <= 36 // Add length validation
}

// Added: Query whitelisting function to validate operations
func isWhitelistedQuery(operation string) bool {
    whitelist := map[string]bool{
        "getProfile": true,
        "updateProfile": true,
        // Add other allowed operations
    }
    return whitelist[operation]
}

// Added: Sanitize log messages to prevent log injection
func sanitizeLogMessage(message string) string {
    // Basic sanitization - remove control characters
    sanitized := regexp.MustCompile(`[\x00-\x1F\x7F]`).ReplaceAllString(message, "")
    return sanitized
}

func(p *Profile)SafeQueryGetData(uid string) error{

	/* this funciton use to get data Profile from database with prepare statement */

	const (
		getProfileSql = 
		`SELECT p.user_id, p.full_name, p.city, p.phone_number 
		FROM Profile as p,Users as u 
		where p.user_id = u.id 
		and u.id=?`) 
	
	stmt, err := DB.Prepare(getProfileSql) //prepare statement 
	if err != nil{
		return err
	}

	defer stmt.Close()
	err = stmt.QueryRow(uid).Scan(&p.Uid,&p.Name,&p.City,&p.PhoneNumber)
	if err != nil{
		return err
	}
	return nil
}
