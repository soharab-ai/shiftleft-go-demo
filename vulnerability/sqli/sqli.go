package sqli

import (
	"log"
	"net/http"
	"strconv"

	"github.com/julienschmidt/httprouter"

	"github.com/ShiftLeftSecurity/shiftleft-go-demo/util"
	// "github.com/ShiftLeftSecurity/shiftleft-go-demo/util/middleware"
)

type SQLI struct{}

func New() SQLI {
	return SQLI{}
}

func (SQLI) SetRouter(r *httprouter.Router) {
	// mw := middleware.New()
	// r.GET("/sqli1", mw.CapturePanic(mw.AuthCheck(sqli1Handler))) // not use logger due to sqlmap request
	// r.GET("/sqli2", mw.CapturePanic(mw.DetectSQLMap(mw.AuthCheck(sqli2Handler))))
	r.GET("/sqli1", sqli1Handler) // not use logger due to sqlmap request
	r.GET("/sqli2", sqli2Handler)
}

func sqli1Handler(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {
// WAFMiddleware implements a simple Web Application Firewall
type WAFMiddleware struct {
    handler http.Handler
}

func NewWAFMiddleware(h http.Handler) *WAFMiddleware {
    return &WAFMiddleware{handler: h}
}

func (m *WAFMiddleware) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    // Implement WAF checks
    sanitizer := bluemonday.UGCPolicy()
    
    // Check for SQL injection patterns in URL parameters
    for key, values := range r.URL.Query() {
        for _, value := range values {
            if containsSQLInjection(value) {
                log.Printf("WAF blocked potential SQL injection in query parameter: %s", sanitizer.Sanitize(key))
                http.Error(w, "Invalid request", http.StatusBadRequest)
                return
            }
        }
    }
    
    // Check cookies for potential injection
    for _, cookie := range r.Cookies() {
        if containsSQLInjection(cookie.Value) {
            log.Printf("WAF blocked potential SQL injection in cookie: %s", sanitizer.Sanitize(cookie.Name))
            http.Error(w, "Invalid request", http.StatusBadRequest)
            return
        }
    }
    
    // Proceed with the request if it passes WAF checks
    m.handler.ServeHTTP(w, r)
}

// containsSQLInjection checks for common SQL injection patterns
func containsSQLInjection(input string) bool {
    // Simple check for SQL injection patterns
    patterns := []string{"'", ";", "--", "/*", "*/", "UNION", "SELECT", "DROP", "DELETE", "INSERT", "UPDATE"}
    
    for _, pattern := range patterns {
        if strings.Contains(strings.ToUpper(input), pattern) {
            return true
        }
    }
    return false
}

func sqli1Handler(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {
    // Create context with timeout
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()
    
    // Initialize sanitizer for input/output
    sanitizer := bluemonday.StrictPolicy()
    
    // Get and validate the UID from cookie with sanitization
    uid := util.GetCookie(r, "Uid")
    uid = sanitizer.Sanitize(uid)
    
    // Role-based access control check
    if !hasPermission(ctx, uid, RoleUser) {
        http.Error(w, "Access denied", http.StatusForbidden)
        return
    }
    
    // Validate the UID from cookie
    _, err := validateUID(uid)
    if err != nil {
        http.Error(w, "Invalid user ID", http.StatusBadRequest)
        log.Printf("Invalid UID format from cookie: %s", sanitizer.Sanitize(err.Error()))
        return
    }

    p := NewProfile()
    data := make(map[string]interfacenull) // data to send to client

    // Always use the safe query method with context
    err = p.SafeQueryGetData(uid)
    if err != nil {
        data["error"] = "No Data Found"
        log.Printf("Query error: %s", sanitizer.Sanitize(err.Error()))
    }

    // Sanitize all data before sending to template
    data["title"] = sanitizer.Sanitize("Sql Injection")
    data["uid"] = sanitizer.Sanitize(strconv.Itoa(p.Uid))
    data["name"] = sanitizer.Sanitize(p.Name)
    data["city"] = sanitizer.Sanitize(p.City)
    data["number"] = sanitizer.Sanitize(p.PhoneNumber)

    util.SafeRender(w, r, "template.sqli1", data)
}

// Setup WAF middleware in main application
func setupRouter() *httprouter.Router {
    router := httprouter.New()
    
    // Apply WAF middleware to sqli1Handler
    sqli1HandlerFunc := func(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
        sqli1Handler(w, r, ps)
    }
    
    // Configure router with WAF middleware for vulnerable endpoints
    waf := NewWAFMiddleware(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        params := httprouter.ParamsFromContext(r.Context())
        sqli1HandlerFunc(w, r, params)
    }))
    
    router.Handler("GET", "/sqli1", waf)
    
    return router
}

func sqli2Handler(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {
	uid := r.FormValue("uid")

	p := NewProfile()

	data := make(map[string]interface{}) // data to send to client

	if !util.CheckLevel(r) { // level == low
		err := p.UnsafeQueryGetData(uid)
		if err != nil {
			log.Printf("sql error")
		}
	} else {
		err := p.SafeQueryGetData(uid)
		if err != nil {
			data["error"] = "No Data Found"
			log.Printf("prepare error : %s", err.Error())
		}
	}

	data["title"] = "Sql Injection"
	data["name"] = p.Name
	data["city"] = p.City
	data["number"] = p.PhoneNumber
	util.SafeRender(w, r, "template.sqli2", data)
}
