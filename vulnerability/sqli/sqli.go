package sqli

import (
	"log"
	"net/http"
	"strconv"

	"github.com/julienschmidt/httprouter"

	"github.com/ShiftLeftSecurity/shiftleft-go-demo/util"
	// "github.com/ShiftLeftSecurity/shiftleft-go-demo/util/middleware"
)

type SQLI struct{}

func New() SQLI {
	return SQLI{}
}

func (SQLI) SetRouter(r *httprouter.Router) {
	// mw := middleware.New()
	// r.GET("/sqli1", mw.CapturePanic(mw.AuthCheck(sqli1Handler))) // not use logger due to sqlmap request
	// r.GET("/sqli2", mw.CapturePanic(mw.DetectSQLMap(mw.AuthCheck(sqli2Handler))))
	r.GET("/sqli1", sqli1Handler) // not use logger due to sqlmap request
	r.GET("/sqli2", sqli2Handler)
}

func sqli1Handler(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {
	uid := util.GetCookie(r, "Uid") // many developer use this style. set reference key in cookie with no sanitize

	/*
		this prevent idor injection but not lead to sql injection

		s := session.New()
		sid := s.GetSession(r, "id")
		if( sid != uid){
			uid = sid
		} */

	p := NewProfile()

	data := make(map[string]interface{}) // data to send to client

	if !util.CheckLevel(r) { // level == low
		err := p.UnsafeQueryGetData(uid)
		if err != nil {
			data["error"] = err.Error()
		}
	} else {
		err := p.SafeQueryGetData(uid)
		if err != nil {
			data["error"] = "No Data Found"
			log.Printf("prepare error : %s", err.Error())
		}
	}
	data["title"] = "Sql Injection"
	data["uid"] = strconv.Itoa(p.Uid)
	data["name"] = p.Name
	data["city"] = p.City
	data["number"] = p.PhoneNumber

	util.SafeRender(w, r, "template.sqli1", data)
}

func sqli2Handler(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {
	uid := r.FormValue("uid")
	
	// Enhanced input validation beyond just numeric checks
	if !isValidUserID(uid) {
		data := make(map[string]interfacenull)
		data["error"] = "Invalid user ID"
		data["title"] = "SQL Injection"
		util.SafeRender(w, r, "template.sqli2", data)
		return
	}

	p := NewProfile()
	data := make(map[string]interfacenull) // data to send to client

	// Improved security level logic - reversed to default to safest approach
	if util.CheckLevel(r) { // high security level
		err := p.SafeQueryGetData(uid)
		if err != nil {
			// Proper error handling without exposing implementation details
			log.Printf("Database error: %s", err.Error()) // Log for debugging
			data["error"] = "An error occurred" // Generic message to user
			util.SafeRender(w, r, "template.sqli2", data)
			return
		}
	} else {
		// Still using a secure method even for low security level
		err := p.SecureQueryGetData(uid)
		if err != nil {
			// Proper error handling without exposing implementation details
			log.Printf("Database error: %s", err.Error()) // Log for debugging
			data["error"] = "An error occurred" // Generic message to user
			util.SafeRender(w, r, "template.sqli2", data)
			return
		}
	}

	data["title"] = "SQL Injection"
	data["name"] = p.Name
	data["city"] = p.City
	data["number"] = p.PhoneNumber
	util.SafeRender(w, r, "template.sqli2", data)
}

// Enhanced validation function with range checks
func isValidUserID(uid string) bool {
	id, err := strconv.Atoi(uid)
	// Added range validation and other business rules
	const MAX_USER_ID = 10000000 // Example max ID value
	return err == nil && id > 0 && id < MAX_USER_ID
}

