package sqli

import (
	"net/http"

	"github.com/gen2brain/go-unarr"
	"github.com/julienschmidt/httprouter"
)

type PathTraversal struct{}

func New() PathTraversal {
	return PathTraversal{}
}

func (PathTraversal) SetRouter(r *httprouter.Router) {
	r.GET("/path-traversal", pathTraversalHandler)
}

func pathTraversalHandler(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {
	// Implement resource limits to prevent DoS attacks
	const MaxFileSize = 10 * 1024 * 1024  // 10MB per file
	const MaxTotalSize = 100 * 1024 * 1024  // 100MB total
	var extractedSize int64
	
	// Read request body into buffer for zip processing
	bodyBytes, err := io.ReadAll(io.LimitReader(r.Body, MaxTotalSize))
	if err != nil {
		http.Error(w, "Error reading request body", http.StatusBadRequest)
		return
	}
	
	// Create a zip reader from the request body
	zipReader, err := zip.NewReader(bytes.NewReader(bodyBytes), int64(len(bodyBytes)))
	if err != nil {
		http.Error(w, "Error processing archive", http.StatusBadRequest)
		return
	}
	
	targetDir := "/tmp/path"
	// Convert to absolute path to ensure no edge cases allow directory traversal
	targetDir, err = filepath.Abs(targetDir)
	if err != nil {
		http.Error(w, "Error resolving target directory", http.StatusInternalServerError)
		return
	}
	
	// Create target directory if it doesn't exist
	if err := os.MkdirAll(targetDir, 0755); err != nil {
		http.Error(w, "Error creating target directory", http.StatusInternalServerError)
		return
	}
	
	// Process each file in the archive individually with path validation
	for _, zipFile := range zipReader.File {
		name := zipFile.Name
		
		// Normalize the path and check for traversal attempts
		cleanPath := filepath.Clean(name)
		if strings.Contains(cleanPath, "..") || strings.HasPrefix(cleanPath, "/") {
			http.Error(w, "Invalid file path in archive", http.StatusBadRequest)
			return
		}
		
		// Implement file extension filtering - block potentially dangerous file types
		dangerousExts := []string{".exe", ".sh", ".bat", ".cmd", ".ps1", ".php", ".pl", ".py"}
		for _, ext := range dangerousExts {
			if strings.HasSuffix(strings.ToLower(cleanPath), ext) {
				http.Error(w, "File type not allowed", http.StatusBadRequest)
				return
			}
		}
		
		// Ensure the final path is within our target directory
		fullPath := filepath.Join(targetDir, cleanPath)
		absPath, err := filepath.Abs(fullPath)
		if err != nil {
			http.Error(w, "Error resolving file path", http.StatusInternalServerError)
			return
		}
		
		if !strings.HasPrefix(absPath, targetDir) {
			http.Error(w, "Invalid file path in archive", http.StatusBadRequest)
			return
		}
		
		// Add symlink protection - check if path already exists as symlink
		if _, err := os.Lstat(absPath); err == nil {
			fileInfo, err := os.Lstat(absPath)
			if err == nil && (fileInfo.Mode()&os.ModeSymlink != 0) {
				http.Error(w, "Symlinks not allowed in archive", http.StatusBadRequest)
				return
			}
		}
		
		// Create directory structure if needed
		if err := os.MkdirAll(filepath.Dir(absPath), 0755); err != nil {
			http.Error(w, "Error creating directory structure", http.StatusInternalServerError)
			return
		}
		
		// Skip directories, only process files
		if zipFile.FileInfo().IsDir() {
			continue
		}
		
		// Check file size before extraction
		if zipFile.UncompressedSize64 > uint64(MaxFileSize) || 
		   (extractedSize + int64(zipFile.UncompressedSize64)) > MaxTotalSize {
			http.Error(w, "Size limit exceeded", http.StatusBadRequest)
			return
		}
		
		// Extract the file
		src, err := zipFile.Open()
		if err != nil {
			http.Error(w, "Error reading file from archive", http.StatusInternalServerError)
			return
		}
		
		// Use safer file operations - prevent overwriting existing files
		outFile, err := os.OpenFile(absPath, os.O_WRONLY|os.O_CREATE|os.O_EXCL, 0644)
		if err != nil {
			src.Close()
			http.Error(w, "Error creating output file", http.StatusInternalServerError)
			return
		}
		
		// Copy with size tracking
		written, err := io.Copy(outFile, src)
		src.Close()
		outFile.Close()
		
		if err != nil {
			http.Error(w, "Error writing output file", http.StatusInternalServerError)
			return
		}
		
		extractedSize += written
	}
	
	w.WriteHeader(http.StatusOK)
}

}
