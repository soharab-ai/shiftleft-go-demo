package sqli

import (
	"net/http"

	"github.com/gen2brain/go-unarr"
	"github.com/julienschmidt/httprouter"
)

type PathTraversal struct{}

func New() PathTraversal {
	return PathTraversal{}
}

func (PathTraversal) SetRouter(r *httprouter.Router) {
	r.GET("/path-traversal", pathTraversalHandler)
}

func pathTraversalHandler(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {
	// Validate content type to ensure it's an archive
	contentType := r.Header.Get("Content-Type")
	if !isValidArchiveContentType(contentType) {
		http.Error(w, "Invalid content type. Expected archive file.", http.StatusBadRequest)
		return
	}

	// Limit the request body size to prevent DoS attacks
	const maxSize = 50 * 1024 * 1024 // 50MB max size
	r.Body = http.MaxBytesReader(w, r.Body, maxSize)

	// Create a temporary file to store the uploaded archive
	tmpFile, err := os.CreateTemp("", "upload-*.zip")
	if err != nil {
		http.Error(w, "Failed to create temporary file", http.StatusInternalServerError)
		return
	}
	defer os.Remove(tmpFile.Name()) // Clean up temporary file
	defer tmpFile.Close()

	// Copy the request body to the temporary file
	if _, err := io.Copy(tmpFile, r.Body); err != nil {
		http.Error(w, "Failed to save uploaded file", http.StatusInternalServerError)
		return
	}

	// Rewind file pointer for reading
	if _, err := tmpFile.Seek(0, 0); err != nil {
		http.Error(w, "Error processing file", http.StatusInternalServerError)
		return
	}

	// Open the archive from the temporary file
	a, err := unarr.NewArchive(tmpFile.Name())
	if err != nil {
		http.Error(w, "Invalid archive format", http.StatusBadRequest)
		return
	}
	defer a.Close()

	// Create a random subdirectory for extraction
	extractionPath := "/tmp/path"
	randomDir, err := createRandomDir(extractionPath)
	if err != nil {
		http.Error(w, "Failed to create extraction directory", http.StatusInternalServerError)
		return
	}

	// Perform pre-extraction scanning
	if err := scanArchiveContents(a); err != nil {
		http.Error(w, "Archive validation failed: "+err.Error(), http.StatusBadRequest)
		return
	}

	// Use secure extraction function
	err = extractArchiveSafely(a, randomDir)
	if err != nil {
		http.Error(w, "Extraction failed: "+err.Error(), http.StatusBadRequest)
		return
	}
	
	w.WriteHeader(http.StatusOK)
}

// isValidArchiveContentType checks if the content type is a recognized archive format
func isValidArchiveContentType(contentType string) bool {
	validTypes := []string{
		"application/zip",
		"application/x-rar-compressed",
		"application/x-7z-compressed",
		"application/x-tar",
		"application/gzip",
		"application/x-bzip2",
	}

	for _, validType := range validTypes {
		if strings.Contains(contentType, validType) {
			return true
		}
	}
	return false
}

// createRandomDir creates a random subdirectory within the base path
func createRandomDir(basePath string) (string, error) {
	// Create base directory if it doesn't exist
	if err := os.MkdirAll(basePath, 0755); err != nil {
		return "", err
	}
	
	// Generate random directory name
	randomBytes := make([]byte, 16)
	if _, err := rand.Read(randomBytes); err != nil {
		return "", err
	}
	randomDir := filepath.Join(basePath, hex.EncodeToString(randomBytes))
	
	// Create the random directory
	if err := os.MkdirAll(randomDir, 0755); err != nil {
		return "", err
	}
	
	return randomDir, nil
}

// scanArchiveContents performs pre-extraction scanning of archive contents
func scanArchiveContents(a *unarr.Archive) error {
	// Reset archive to beginning
	if err := a.Reset(); err != nil {
		return err
	}
	
	// Maximum allowed file size
	const maxFileSize int64 = 100 * 1024 * 1024 // 100MB
	
	// Maximum number of files
	const maxFileCount = 1000
	
	fileCount := 0
	totalSize := int64(0)
	
	// First pass: check all files without extracting
	for a.Next() {
		fileCount++
		if fileCount > maxFileCount {
			return fmt.Errorf("too many files in archive (max: %d)", maxFileCount)
		}
		
		size, err := a.Size()
		if err != nil {
			return err
		}
		
		if size > maxFileSize {
			return fmt.Errorf("file too large: %d bytes (max: %d)", size, maxFileSize)
		}
		
		totalSize += size
		if totalSize > maxFileSize*10 {
			return fmt.Errorf("total archive size too large")
		}
		
		fileName, err := a.Name()
		if err != nil {
			return err
		}
		
		// Validate file path
		if _, err := sanitizePath(fileName); err != nil {
			return err
		}
	}
	
	// Reset archive for actual extraction
	return a.Reset()
}

// sanitizePath validates and cleans file paths to prevent directory traversal
func sanitizePath(filePath string) (string, error) {
	// Take just the base name to remove any directory components
	// This is more restrictive than the suggested mitigation but safer
	clean := filepath.Base(filePath)
	
	// Reject files with potentially dangerous names
	if clean == "" || clean == "." || clean == ".." {
		return "", fmt.Errorf("invalid file name")
	}
	
	// Check for file names with special characters or device names
	if strings.ContainsAny(clean, "\\/:*?\"<>|") {
		return "", fmt.Errorf("file name contains invalid characters")
	}
	
	return clean, nil
}

// atomicWriteFile writes data to a file atomically to prevent TOCTOU issues
func atomicWriteFile(filename string, data []byte, perm os.FileMode) error {
	// Create a temporary file in the same directory
	dir := filepath.Dir(filename)
	tempFile, err := os.CreateTemp(dir, ".tmp-")
	if err != nil {
		return err
	}
	tempName := tempFile.Name()
	
	// Clean up in case of error
	defer func() {
		tempFile.Close()
		os.Remove(tempName)
	}()
	
	// Write data to temp file
	if _, err := tempFile.Write(data); err != nil {
		return err
	}
	
	// Sync to ensure data is written to disk
	if err := tempFile.Sync(); err != nil {
		return err
	}
	
	// Close the file before renaming
	if err := tempFile.Close(); err != nil {
		return err
	}
	
	// Set permissions
	if err := os.Chmod(tempName, perm); err != nil {
		return err
	}
	
	// Rename the temp file to the target filename (atomic on most filesystems)
	return os.Rename(tempName, filename)
}

// extractArchiveSafely extracts files from archive with path validation
func extractArchiveSafely(a *unarr.Archive, destinationDir string) error {
	// Ensure destination directory exists
	if err := os.MkdirAll(destinationDir, 0755); err != nil {
		return err
	}
	
	// Get the absolute path of the destination directory
	absDestDir, err := filepath.Abs(destinationDir)
	if err != nil {
		return err
	}
	
	// For each file in the archive
	for a.Next() {
		fileName, err := a.Name()
		if err != nil {
			return err
		}
		
		// Sanitize file path - this returns only the base name
		clean, err := sanitizePath(fileName)
		if err != nil {
			return fmt.Errorf("invalid file name '%s': %v", fileName, err)
		}
		
		// Construct destination path using base name only
		destPath := filepath.Join(destinationDir, clean)
		
		// Use filepath.Rel to ensure path doesn't escape the target directory
		relPath, err := filepath.Rel(absDestDir, destPath)
		if err != nil || strings.Contains(relPath, "..") {
			return fmt.Errorf("path traversal attempt detected for file: %s", fileName)
		}
		
		// Check if file already exists
		if _, err := os.Stat(destPath); err == nil {
			// Check if it's a symlink
			info, err := os.Lstat(destPath)
			if err != nil {
				return err
			}
			
			if info.Mode()&os.ModeSymlink != 0 {
				return fmt.Errorf("symlinks are not allowed: %s", clean)
			}
		}
		
		// Create directories for this file
		if err := os.MkdirAll(filepath.Dir(destPath), 0755); err != nil {
			return err
		}
		
		// Extract current file content
		content, err := a.ReadAll()
		if err != nil {
			return err
		}
		
		// Write file using atomic operation to prevent race conditions
		if err := atomicWriteFile(destPath, content, 0644); err != nil {
			return err
		}
	}
	
	return nil
}

}
