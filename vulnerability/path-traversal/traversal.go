package sqli

import (
	"net/http"

	"github.com/gen2brain/go-unarr"
	"github.com/julienschmidt/httprouter"
)

type PathTraversal struct{}

func New() PathTraversal {
	return PathTraversal{}
}

func (PathTraversal) SetRouter(r *httprouter.Router) {
	r.GET("/path-traversal", pathTraversalHandler)
}

func pathTraversalHandler(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {
    // Validate content type to ensure only archives are processed
    contentType := r.Header.Get("Content-Type")
    if !isAllowedArchiveType(contentType) {
        http.Error(w, "Unsupported archive format", http.StatusBadRequest)
        return
    }

    // Set a maximum size for the archive to prevent zip bombs
    const maxArchiveSize = 50 * 1024 * 1024 // 50MB limit
    r.Body = http.MaxBytesReader(w, r.Body, maxArchiveSize)

    // Create a temporary file to store the archive data
    tempFile, err := os.CreateTemp("", "archive-*")
    if err != nil {
        http.Error(w, "Failed to create temporary file", http.StatusInternalServerError)
        return
    }
    defer os.Remove(tempFile.Name())
    defer tempFile.Close()

    // Copy the request body to the temporary file
    if _, err := io.Copy(tempFile, r.Body); err != nil {
        http.Error(w, "Failed to read archive data", http.StatusBadRequest)
        return
    }
    
    // Rewind the file for reading
    if _, err := tempFile.Seek(0, 0); err != nil {
        http.Error(w, "Failed to process archive", http.StatusInternalServerError)
        return
    }

    // Create unique extraction directory per request
    uniqueID, err := uuid.NewRandom()
    if err != nil {
        http.Error(w, "Failed to generate extraction path", http.StatusInternalServerError)
        return
    }
    baseDestDir := "/tmp/path"
    destinationDir := filepath.Join(baseDestDir, uniqueID.String())
    
    // Create destination directory with proper permissions
    if err := os.MkdirAll(destinationDir, 0750); err != nil {
        http.Error(w, "Failed to create extraction directory", http.StatusInternalServerError)
        return
    }
    
    // Implement cleanup mechanism for temporary files
    defer func() {
        // Schedule cleanup after processing is complete (could be moved to a separate goroutine with a longer timeout)
        go func() {
            time.Sleep(15 * time.Minute)
            os.RemoveAll(destinationDir)
        }()
    }()

    // First pass: validate all files in the archive
    a, err := unarr.NewArchive(tempFile.Name())
    if err != nil {
        http.Error(w, "Invalid archive format", http.StatusBadRequest)
        return
    }
    
    // Set extraction timeout
    timeoutChan := make(chan bool, 1)
    go func() {
        time.Sleep(2 * time.Minute) // 2 minute timeout
        timeoutChan <- true
    }()

    // Maximum number of files allowed in archive
    const maxFileCount = 1000
    fileCount := 0
    
    // Define allowed extensions
    allowedExtensions := map[string]bool{
        ".txt": true, ".pdf": true, ".doc": true, ".docx": true,
        ".xls": true, ".xlsx": true, ".jpg": true, ".png": true,
    }

    // Validate all files in the archive
    validationFailed := false
    validationError := ""

    for {
        select {
        case <-timeoutChan:
            a.Close()
            http.Error(w, "Archive processing timeout exceeded", http.StatusRequestTimeout)
            return
        default:
            err = a.Entry()
            if err != nil {
                // End of archive or error
                break
            }
            
            fileCount++
            if fileCount > maxFileCount {
                validationFailed = true
                validationError = "Too many files in archive"
                break
            }
            
            filePath := a.Name()
            
            // Path traversal validation
            if !isValidPath(filePath, destinationDir) {
                validationFailed = true
                validationError = "Invalid file path in archive: potential directory traversal"
                break
            }
            
            // Extension whitelist check
            ext := strings.ToLower(filepath.Ext(filePath))
            if !allowedExtensions[ext] {
                validationFailed = true
                validationError = "Forbidden file type in archive"
                break
            }
            
            // Filename sanitization - reject files with suspicious characters
            if !hasValidFilename(filePath) {
                validationFailed = true
                validationError = "Invalid filename in archive"
                break
            }
        }
        
        if err != nil || validationFailed {
            break
        }
    }
    
    a.Close()
    
    // If validation failed, return error
    if validationFailed {
        http.Error(w, validationError, http.StatusBadRequest)
        return
    }
    
    // Second pass: extract the archive with validated paths
    a, err = unarr.NewArchive(tempFile.Name())
    if err != nil {
        http.Error(w, "Failed to reopen archive", http.StatusInternalServerError)
        return
    }
    defer a.Close()
    
    // Reset the timeout for extraction
    extractionTimeoutChan := make(chan bool, 1)
    go func() {
        time.Sleep(5 * time.Minute) // 5 minute timeout for extraction
        extractionTimeoutChan <- true
    }()
    
    // Extract files with proper error handling
    extractionDone := make(chan bool, 1)
    extractionError := make(chan error, 1)
    
    go func() {
        _, err := a.Extract(destinationDir)
        if err != nil {
            extractionError <- err
        } else {
            extractionDone <- true
        }
    }()
    
    select {
    case <-extractionDone:
        // Set proper permissions on extracted files
        err = secureExtractedFiles(destinationDir)
        if err != nil {
            http.Error(w, "Failed to secure extracted files", http.StatusInternalServerError)
            return
        }
        
        w.WriteHeader(http.StatusOK)
        w.Write([]byte("Archive extracted successfully"))
        
    case err := <-extractionError:
        http.Error(w, fmt.Sprintf("Extraction failed: %v", err), http.StatusInternalServerError)
        return
        
    case <-extractionTimeoutChan:
        http.Error(w, "Extraction timeout exceeded", http.StatusRequestTimeout)
        return
    }
}

// Helper function to validate file paths against directory traversal
func isValidPath(filePath string, destinationDir string) bool {
    // Clean and normalize the path to handle different forms of traversal attempts
    filePath = filepath.Clean(filePath)
    
    destPath := filepath.Join(destinationDir, filePath)
    relPath, err := filepath.Rel(destinationDir, destPath)
    if err != nil || strings.HasPrefix(relPath, "..") || strings.HasPrefix(relPath, "/") {
        return false
    }
    return true
}

// Helper function to validate filename characters
func hasValidFilename(filename string) bool {
    // Check for suspicious characters or patterns
    suspicious := []string{":", ";", "&", "|", "`", "$", "<", ">", "\"", "'"}
    for _, char := range suspicious {
        if strings.Contains(filename, char) {
            return false
        }
    }
    
    // Ensure filename is not too long
    if len(filepath.Base(filename)) > 255 {
        return false
    }
    
    return true
}

// Helper function to validate content type
func isAllowedArchiveType(contentType string) bool {
    allowedTypes := []string{
        "application/zip", 
        "application/x-rar-compressed", 
        "application/x-7z-compressed",
        "application/x-tar", 
        "application/gzip"
    }
    
    for _, allowed := range allowedTypes {
        if strings.HasPrefix(contentType, allowed) {
            return true
        }
    }
    return false
}

// Helper function to secure extracted files
func secureExtractedFiles(directory string) error {
    return filepath.Walk(directory, func(path string, info os.FileInfo, err error) error {
        if err != nil {
            return err
        }
        
        // Set secure permissions: read-only for files, execute+read for directories
        if info.IsDir() {
            return os.Chmod(path, 0750) // rwxr-x---
        }
        return os.Chmod(path, 0640) // rw-r-----
        
    })
}

}
