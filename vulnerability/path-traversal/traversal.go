package sqli

import (
	"net/http"

	"github.com/gen2brain/go-unarr"
	"github.com/julienschmidt/httprouter"
)

type PathTraversal struct{}

func New() PathTraversal {
	return PathTraversal{}
}

func (PathTraversal) SetRouter(r *httprouter.Router) {
	r.GET("/path-traversal", pathTraversalHandler)
}

func pathTraversalHandler(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {
// Global rate limiter to prevent DoS attacks
var limiter = rate.NewLimiter(rate.Limit(10), 30) // 10 requests per second with burst of 30

// Constants for security controls
const (
	maxAllowedSize int64 = 10 * 1024 * 1024 // 10MB max file size
	baseTargetDir  = "/tmp/path"            // Base extraction directory
)

// List of allowed archive types and file extensions
var (
	allowedArchiveTypes = map[string]bool{
		"application/zip":    true,
		"application/x-rar":  true,
		"application/x-tar":  true,
		"application/gzip":   true,
		"application/x-gzip": true,
	}

	allowedFileExtensions = map[string]bool{
		".txt":  true,
		".csv":  true,
		".json": true,
		".xml":  true,
		".md":   true,
		".html": true,
		".css":  true,
		".js":   true,
		".png":  true,
		".jpg":  true,
		".jpeg": true,
		".gif":  true,
		".pdf":  true,
	}
)

func pathTraversalHandler(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {
	// Implement rate limiting to prevent DoS attacks
	if !limiter.Allow() {
		http.Error(w, "Rate limit exceeded", http.StatusTooManyRequests)
		return
	}

	// Create context with timeout to prevent resource exhaustion
	ctx, cancel := context.WithTimeout(r.Context(), 30*time.Second)
	defer cancel()

	// Content-Type verification
	contentType := r.Header.Get("Content-Type")
	if !isAllowedArchiveType(contentType) {
		http.Error(w, "Unsupported archive format", http.StatusBadRequest)
		return
	}

	// Limit request body size to prevent DoS attacks
	r.Body = http.MaxBytesReader(w, r.Body, maxAllowedSize)

	a, err := unarr.NewArchiveFromReader(r.Body)
	if err != nil {
		http.Error(w, "Failed to read archive", http.StatusBadRequest)
		return
	}
	defer a.Close()

	// Create a unique sandbox directory for this extraction
	uniqueDir := filepath.Join(baseTargetDir, uuid.NewString())
	
	// Use the context to potentially cancel long-running extractions
	errChan := make(chan error, 1)
	go func() {
		errChan <- secureExtract(a, uniqueDir)
	}()

	select {
	case <-ctx.Done():
		http.Error(w, "Extraction timed out", http.StatusRequestTimeout)
		return
	case err := <-errChan:
		if err != nil {
			http.Error(w, "Extraction failed: "+err.Error(), http.StatusBadRequest)
			return
		}
	}

	w.WriteHeader(http.StatusOK)
	w.Write([]byte("Files extracted successfully"))
}

// isAllowedArchiveType verifies if the content type is an allowed archive format
func isAllowedArchiveType(contentType string) bool {
	// Parse the content type to handle parameters
	mediaType, _, err := mime.ParseMediaType(contentType)
	if err != nil {
		return false
	}
	return allowedArchiveTypes[mediaType]
}

// isAllowedFileType checks if the file extension is in the whitelist
func isAllowedFileType(extension string) bool {
	return allowedFileExtensions[strings.ToLower(extension)]
}

// isSymlink checks if a path is a symbolic link
func isSymlink(path string) bool {
	info, err := os.Lstat(path)
	if err != nil {
		return false
	}
	return info.Mode()&os.ModeSymlink != 0
}

// validateFilePath checks if a path is safe to extract
func validateFilePath(fileName string, targetDir string) error {
	// Check for basic path traversal attempts
	if strings.Contains(fileName, "../") || strings.Contains(fileName, "..\\") {
		return errors.New("path traversal attempt detected")
	}
	
	// Check file extension
	if !isAllowedFileType(filepath.Ext(fileName)) {
		return errors.New("file type not allowed")
	}
	
	// Use absolute path canonicalization for stronger validation
	absPath, err := filepath.Abs(filepath.Join(targetDir, fileName))
	if err != nil {
		return errors.New("invalid file path")
	}
	
	// Ensure the final path is within the intended directory
	if !strings.HasPrefix(absPath, targetDir) {
		return errors.New("invalid file path: attempts to write outside target directory")
	}
	
	return nil
}

// secureExtract safely extracts files from an archive after validating paths
func secureExtract(a *unarr.Archive, targetDir string) error {
	// Create target directory if it doesn't exist
	if err := os.MkdirAll(targetDir, 0750); err != nil {
		return err
	}

	for {
		err := a.Entry()
		if err != nil {
			if err == io.EOF {
				break
			}
			return err
		}
		
		fileName := a.Name()
		fileSize := a.Size()
		
		// Check file size limit
		if fileSize > maxAllowedSize {
			return errors.New("file exceeds maximum allowed size")
		}
		
		// Validate the file path before extraction
		if err := validateFilePath(fileName, targetDir); err != nil {
			return err
		}
		
		// Safe to extract this file
		outputPath := filepath.Join(targetDir, fileName)
		
		// Create directory for file if needed
		dir := filepath.Dir(outputPath)
		if err := os.MkdirAll(dir, 0750); err != nil {
			return err
		}
		
		// Check for symbolic links
		if isSymlink(outputPath) {
			return errors.New("symbolic links are not allowed")
		}
		
		// Extract file content
		content, err := a.ReadAll()
		if err != nil {
			return err
		}
		
		// Write file with restricted permissions
		if err := ioutil.WriteFile(outputPath, content, 0640); err != nil {
			return err
		}
	}
	return nil
}
