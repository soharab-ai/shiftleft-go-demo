package sqli

import (
	"net/http"

	"github.com/gen2brain/go-unarr"
	"github.com/julienschmidt/httprouter"
)

type PathTraversal struct{}

func New() PathTraversal {
	return PathTraversal{}
}

func (PathTraversal) SetRouter(r *httprouter.Router) {
	r.GET("/path-traversal", pathTraversalHandler)
}

func pathTraversalHandler(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {
	a, err := unarr.NewArchiveFromReader(r.Body)
// Define configuration options for secure archive extraction
type ExtractorConfig struct {
	MaxFileSize      int64                // Maximum allowed file size in bytes
	AllowedExtensions map[string]bool     // Map of allowed file extensions
	MaxCompressionRatio float64           // Maximum allowed compression ratio
	DestinationDir   string               // Destination directory for extraction
	Logger           *log.Logger          // Custom logger for audit trail
}

// Default configuration values
var DefaultConfig = ExtractorConfig{
	MaxFileSize:      1024 * 1024 * 50,    // 50MB max file size
	AllowedExtensions: map[string]bool{    // Safe extensions allowlist
		".txt": true, ".pdf": true, ".png": true, 
		".jpg": true, ".jpeg": true, ".gif": true,
		".doc": true, ".docx": true, ".xls": true, 
		".xlsx": true, ".ppt": true, ".pptx": true,
		".csv": true, ".json": true, ".xml": true,
	},
	MaxCompressionRatio: 100.0,            // Limit ratio to detect zip bombs
	Logger:             log.New(os.Stderr, "[ArchiveExtractor] ", log.LstdFlags),
}

// Define a secure archive extractor struct
type ArchiveExtractor struct {
	zipPath string
	config  ExtractorConfig
	totalExtractedSize int64
	totalCompressedSize int64
}

// Error types for better error handling and reporting
var (
	ErrPathTraversal      = errors.New("path traversal attempt detected")
	ErrInvalidExtension   = errors.New("file has disallowed extension")
	ErrFileTooLarge       = errors.New("file exceeds maximum allowed size")
	ErrCompressionRatio   = errors.New("compression ratio exceeds threshold (potential zip bomb)")
	ErrSymlinkDetected    = errors.New("symbolic link detected in archive")
	ErrInvalidPath        = errors.New("invalid or unsafe path detected")
)

// Helper function to validate file paths to prevent directory traversal
func validateFilePath(filePath string, destinationDir string) (bool, error) {
	// Canonicalize the path to handle encoding tricks
	cleanPath := filepath.Clean(filePath)
	
	// Check for any suspicious path components
	pathPattern := regexp.MustCompile(`(?i)[<>:"|?*]|^\.\.?(/|\\)|(/|\\)\.\.?(/|\\)|(/|\\)\.\.?$`)
	if pathPattern.MatchString(cleanPath) {
		return false, ErrPathTraversal
	}

	// Get the absolute path of the destination directory
	destAbs, err := filepath.Abs(destinationDir)
	if err != nil {
		return false, err
	}
	
	// Get the absolute path of the target file
	targetPath := filepath.Join(destinationDir, cleanPath)
	targetAbs, err := filepath.Abs(targetPath)
	if err != nil {
		return false, err
	}
	
	// Check if the target path is within the destination directory
	if !strings.HasPrefix(targetAbs, destAbs) {
		return false, ErrPathTraversal
	}
	
	return true, nil
}

// Validates file extension against allowlist
func validateFileExtension(filename string, allowedExts map[string]bool) bool {
	ext := strings.ToLower(filepath.Ext(filename))
	return allowedExts[ext]
}

// Detects if file might be a symbolic link
func isSymLink(file *zip.File) bool {
	return file.Mode()&os.ModeSymlink != 0
}

// Create a new archive extractor with custom configuration
func NewArchiveExtractorWithConfig(zipPath string, config ExtractorConfig) (*ArchiveExtractor, error) {
	// Validate zip file exists
	if _, err := os.Stat(zipPath); os.IsNotExist(err) {
		return nil, fmt.Errorf("zip file not found: %v", err)
	}

	a := &ArchiveExtractor{
		zipPath: zipPath, 
		config:  config,
	}
	return a, nil
}

// Create a new archive extractor with default configuration
func NewArchiveExtractor(zipPath string) (*ArchiveExtractor, error) {
	return NewArchiveExtractorWithConfig(zipPath, DefaultConfig)
}

// ValidateFileContent checks file content type
func validateFileContent(file io.Reader, filename string) (string, error) {
	// Read a small buffer to detect content type
	buffer := make([]byte, 512)
	n, err := file.Read(buffer)
	if err != nil && err != io.EOF {
		return "", err
	}
	
	// Detect content type
	contentType := mime.TypeByExtension(filepath.Ext(filename))
	if contentType == "" {
		contentType = http.DetectContentType(buffer[:n])
	}
	
	return contentType, nil
}

// createDirectory safely creates a directory with validations
func (a *ArchiveExtractor) createDirectory(path string) error {
	// Validate each path component
	components := strings.Split(path, string(os.PathSeparator))
	currentPath := ""
	
	for _, comp := range components {
		// Skip empty components
		if comp == "" {
			continue
		}
		
		// Update current path
		if currentPath == "" {
			currentPath = comp
		} else {
			currentPath = filepath.Join(currentPath, comp)
		}
		
		// Validate the current path
		valid, err := validateFilePath(currentPath, a.config.DestinationDir)
		if !valid || err != nil {
			return fmt.Errorf("invalid path component: %v", err)
		}
		
		// Create directory with restricted permissions
		dirPath := filepath.Join(a.config.DestinationDir, currentPath)
		err = os.Mkdir(dirPath, 0755) // More restrictive permissions
		if err != nil && !os.IsExist(err) {
			return err
		}
	}
	
	return nil
}

// Extract safely extracts files from the archive to the destination
func (a *ArchiveExtractor) Extract(destination string) ([]string, error) {
	a.config.DestinationDir = destination
	a.totalCompressedSize = 0
	a.totalExtractedSize = 0
	
	startTime := time.Now()
	a.config.Logger.Printf("Starting extraction to %s", destination)
	
	reader, err := zip.OpenReader(a.zipPath)
	if err != nil {
		a.config.Logger.Printf("Failed to open zip: %v", err)
		return nil, err
	}
	defer reader.Close()
	
	// Pre-scan archive for total size to detect zip bombs
	for _, file := range reader.File {
		a.totalCompressedSize += int64(file.CompressedSize64)
	}
	
	var extractedFiles []string
	
	// Iterate through each file in the archive
	for _, file := range reader.File {
		// Check for symbolic links
		if isSymLink(file) {
			a.config.Logger.Printf("Security alert: Symbolic link detected: %s", file.Name)
			continue // Skip symbolic links
		}
		
		// Check file size
		if file.UncompressedSize64 > uint64(a.config.MaxFileSize) {
			a.config.Logger.Printf("Security alert: File too large: %s (%d bytes)", 
				file.Name, file.UncompressedSize64)
			continue
		}
		
		// Check compression ratio for individual file
		if file.UncompressedSize64 > 0 {
			ratio := float64(file.UncompressedSize64) / float64(file.CompressedSize64)
			if ratio > a.config.MaxCompressionRatio {
				a.config.Logger.Printf("Security alert: Suspicious compression ratio (%.2f): %s", 
					ratio, file.Name)
				continue
			}
		}
		
		// Update total extracted size for zip bomb detection
		a.totalExtractedSize += int64(file.UncompressedSize64)
		overallRatio := float64(a.totalExtractedSize) / float64(a.totalCompressedSize)
		if overallRatio > a.config.MaxCompressionRatio {
			a.config.Logger.Printf("Security alert: Potential zip bomb detected. Overall ratio: %.2f", 
				overallRatio)
			return extractedFiles, ErrCompressionRatio
		}
		
		// Canonicalize and validate the file path
		valid, err := validateFilePath(file.Name, destination)
		if !valid || err != nil {
			a.config.Logger.Printf("Security alert: Path traversal attempt: %s (%v)", file.Name, err)
			continue
		}
		
		// Validate file extension if it's not a directory
		if !file.FileInfo().IsDir() {
			if !validateFileExtension(file.Name, a.config.AllowedExtensions) {
				a.config.Logger.Printf("Security alert: Disallowed file extension: %s", file.Name)
				continue
			}
		}
		
		filePath := filepath.Join(destination, file.Name)
		extractedFiles = append(extractedFiles, filePath)
		
		if file.FileInfo().IsDir() {
			// Use our secure directory creation function
			if err := a.createDirectory(file.Name); err != nil {
				a.config.Logger.Printf("Failed to create directory: %v", err)
				continue
			}
			continue
		}
		
		// Create parent directories securely
		parentDir := filepath.Dir(filePath)
		if err := a.createDirectory(filepath.Dir(file.Name)); err != nil {
			a.config.Logger.Printf("Failed to create parent directory: %v", err)
			continue
		}
		
		// Open the file with restricted permissions
		dstFile, err := os.OpenFile(filePath, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0644)
		if err != nil {
			a.config.Logger.Printf("Failed to create file: %v", err)
			continue
		}
		
		srcFile, err := file.Open()
		if err != nil {
			dstFile.Close()
			a.config.Logger.Printf("Failed to open compressed file: %v", err)
			continue
		}
		
		// Validate file content
		contentType, err := validateFileContent(srcFile, file.Name)
		if err != nil {
			srcFile.Close()
			dstFile.Close()
			a.config.Logger.Printf("Failed to validate content: %v", err)
			continue
		}
		
		// Reset the read position after content validation
		srcFile.Close()
		srcFile, err = file.Open()
		if err != nil {
			dstFile.Close()
			a.config.Logger.Printf("Failed to reopen compressed file: %v", err)
			continue
		}
		
		// Log the extraction with file metadata
		a.config.Logger.Printf("Extracting: %s (size: %d, type: %s)", 
			file.Name, file.UncompressedSize64, contentType)
		
		// Copy file content with size limiting
		written, err := io.CopyN(dstFile, srcFile, a.config.MaxFileSize+1)
		if written > a.config.MaxFileSize {
			// This shouldn't happen due to earlier check, but just in case
			a.config.Logger.Printf("Security alert: File size exceeded limit during copy: %s", file.Name)
			os.Remove(filePath) // Remove the partially written file
		}
		
		srcFile.Close()
		dstFile.Close()
		
		if err != nil && err != io.EOF {
			a.config.Logger.Printf("Error during file copy: %v", err)
			return extractedFiles, err
		}
	}
	
	duration := time.Since(startTime)
	a.config.Logger.Printf("Extraction completed: %d files extracted in %v", 
		len(extractedFiles), duration)
	
	return extractedFiles, nil
}

// Close closes the archive
func (a *ArchiveExtractor) Close() error {
	// No resources to release in this implementation
	return nil
}

func pathTraversalHandler() {
	// Create a logger for audit trail
	auditLogger := log.New(os.Stderr, "[ArchiveAudit] ", 
		log.Ldate|log.Ltime|log.Lshortfile|log.LUTC)
	
	// Create a custom configuration with enhanced security
	config := DefaultConfig
	config.MaxFileSize = 10 * 1024 * 1024 // 10MB
	config.MaxCompressionRatio = 50.0     // Stricter ratio
	config.Logger = auditLogger
	
	// Create a new archive extractor with custom config
	a, err := NewArchiveExtractorWithConfig("path/to/archive.zip", config)
	if err != nil {
		auditLogger.Printf("Failed to initialize extractor: %v", err)
		panic(err)
	}
	defer a.Close()

	// Fixed: Extract with comprehensive security measures
	extractPath := "/tmp/path"
	files, err := a.Extract(extractPath)
	if err != nil {
		auditLogger.Printf("Extraction error: %v", err)
		panic(err)
	}
	
	auditLogger.Printf("Successfully extracted %d files to %s", len(files), extractPath)
}

